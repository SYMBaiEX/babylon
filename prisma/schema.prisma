generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_DATABASE_URL")
}

model Actor {
  id                                                  String              @id
  name                                                String
  description                                         String?
  domain                                              String[]
  personality                                         String?
  tier                                                String?
  affiliations                                        String[]
  postStyle                                           String?
  postExample                                         String[]
  role                                                String?
  initialLuck                                         String              @default("medium")
  initialMood                                         Float               @default(0)
  createdAt                                           DateTime            @default(now())
  updatedAt                                           DateTime
  hasPool                                             Boolean             @default(false)
  profileImageUrl                                     String?
  reputationPoints                                    Int                 @default(10000)
  tradingBalance                                      Decimal             @default(10000) @db.Decimal(18, 2)
  ActorFollow_ActorFollow_followerIdToActor           ActorFollow[]       @relation("ActorFollow_followerIdToActor")
  ActorFollow_ActorFollow_followingIdToActor          ActorFollow[]       @relation("ActorFollow_followingIdToActor")
  ActorRelationship_ActorRelationship_actor1IdToActor ActorRelationship[] @relation("ActorRelationship_actor1IdToActor")
  ActorRelationship_ActorRelationship_actor2IdToActor ActorRelationship[] @relation("ActorRelationship_actor2IdToActor")
  NPCTrade                                            NPCTrade[]
  Pool                                                Pool[]
  UserActorFollow                                     UserActorFollow[]

  @@index([hasPool])
  @@index([reputationPoints(sort: Desc)])
  @@index([role])
  @@index([tier])
}

model ActorFollow {
  id                                   String   @id
  followerId                           String
  followingId                          String
  createdAt                            DateTime @default(now())
  isMutual                             Boolean  @default(false)
  Actor_ActorFollow_followerIdToActor  Actor    @relation("ActorFollow_followerIdToActor", fields: [followerId], references: [id], onDelete: Cascade)
  Actor_ActorFollow_followingIdToActor Actor    @relation("ActorFollow_followingIdToActor", fields: [followingId], references: [id], onDelete: Cascade)

  @@unique([followerId, followingId])
  @@index([followerId])
  @@index([followingId])
  @@index([isMutual])
}

model ActorRelationship {
  id                                      String   @id
  actor1Id                                String
  actor2Id                                String
  relationshipType                        String
  strength                                Float
  sentiment                               Float
  isPublic                                Boolean  @default(true)
  history                                 String?
  affects                                 Json?
  createdAt                               DateTime @default(now())
  updatedAt                               DateTime
  Actor_ActorRelationship_actor1IdToActor Actor    @relation("ActorRelationship_actor1IdToActor", fields: [actor1Id], references: [id], onDelete: Cascade)
  Actor_ActorRelationship_actor2IdToActor Actor    @relation("ActorRelationship_actor2IdToActor", fields: [actor2Id], references: [id], onDelete: Cascade)

  @@unique([actor1Id, actor2Id])
  @@index([actor1Id])
  @@index([actor2Id])
  @@index([relationshipType])
  @@index([sentiment])
  @@index([strength])
}

model AgentPerformanceMetrics {
  id                    String    @id
  userId                String    @unique
  gamesPlayed           Int       @default(0)
  gamesWon              Int       @default(0)
  averageGameScore      Float     @default(0)
  lastGameScore         Float?
  lastGamePlayedAt      DateTime?
  normalizedPnL         Float     @default(0.5)
  totalTrades           Int       @default(0)
  profitableTrades      Int       @default(0)
  winRate               Float     @default(0)
  averageROI            Float     @default(0)
  sharpeRatio           Float?
  totalFeedbackCount    Int       @default(0)
  averageFeedbackScore  Float     @default(50)
  averageRating         Float?
  positiveCount         Int       @default(0)
  neutralCount          Int       @default(0)
  negativeCount         Int       @default(0)
  reputationScore       Float     @default(50)
  trustLevel            String    @default("UNRATED")
  confidenceScore       Float     @default(0)
  onChainReputationSync Boolean   @default(false)
  lastSyncedAt          DateTime?
  onChainTrustScore     Float?
  onChainAccuracyScore  Float?
  firstActivityAt       DateTime?
  lastActivityAt        DateTime?
  totalInteractions     Int       @default(0)
  createdAt             DateTime  @default(now())
  updatedAt             DateTime
  User                  User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([gamesPlayed(sort: Desc)])
  @@index([normalizedPnL(sort: Desc)])
  @@index([reputationScore(sort: Desc)])
  @@index([trustLevel])
  @@index([updatedAt(sort: Desc)])
}

model BalanceTransaction {
  id            String   @id
  userId        String
  type          String
  amount        Decimal  @db.Decimal(18, 2)
  balanceBefore Decimal  @db.Decimal(18, 2)
  balanceAfter  Decimal  @db.Decimal(18, 2)
  relatedId     String?
  description   String?
  createdAt     DateTime @default(now())
  User          User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([type])
  @@index([userId, createdAt(sort: Desc)])
}

model Chat {
  id              String            @id
  name            String?
  isGroup         Boolean           @default(false)
  groupId         String?           // Link to UserGroup for group chats
  gameId          String?
  dayNumber       Int?
  createdAt       DateTime          @default(now())
  updatedAt       DateTime
  ChatParticipant ChatParticipant[]
  Message         Message[]

  @@index([gameId, dayNumber])
  @@index([isGroup])
  @@index([groupId])
}

model ChatParticipant {
  id       String   @id
  chatId   String
  userId   String
  joinedAt DateTime @default(now())
  Chat     Chat     @relation(fields: [chatId], references: [id], onDelete: Cascade)

  @@unique([chatId, userId])
  @@index([chatId])
  @@index([userId])
}

model DMAcceptance {
  id          String    @id
  chatId      String    @unique
  userId      String    // User who needs to accept
  otherUserId String    // The person who initiated the DM
  status      String    @default("pending") // "pending" | "accepted" | "rejected"
  createdAt   DateTime  @default(now())
  acceptedAt  DateTime?
  rejectedAt  DateTime?

  @@index([userId, status])
  @@index([status, createdAt(sort: Desc)])
}

model Comment {
  id              String     @id
  content         String
  postId          String
  authorId        String
  parentCommentId String?
  createdAt       DateTime   @default(now())
  updatedAt       DateTime
  deletedAt       DateTime?
  User            User       @relation(fields: [authorId], references: [id], onDelete: Cascade)
  Comment         Comment?   @relation("CommentToComment", fields: [parentCommentId], references: [id], onDelete: Cascade)
  other_Comment   Comment[]  @relation("CommentToComment")
  Post            Post       @relation(fields: [postId], references: [id], onDelete: Cascade)
  Reaction        Reaction[]

  @@index([authorId])
  @@index([deletedAt])
  @@index([parentCommentId])
  @@index([postId, createdAt(sort: Desc)])
  @@index([postId, deletedAt]) // For filtering deleted comments
}

model Favorite {
  id                               String   @id
  userId                           String
  targetUserId                     String
  createdAt                        DateTime @default(now())
  User_Favorite_targetUserIdToUser User     @relation("Favorite_targetUserIdToUser", fields: [targetUserId], references: [id], onDelete: Cascade)
  User_Favorite_userIdToUser       User     @relation("Favorite_userIdToUser", fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, targetUserId])
  @@index([targetUserId])
  @@index([userId])
}

model Feedback {
  id                             String   @id
  fromUserId                     String?
  fromAgentId                    String?
  toUserId                       String?
  toAgentId                      String?
  score                          Int
  rating                         Int?
  comment                        String?
  category                       String?
  gameId                         String?
  tradeId                        String?
  positionId                     String?
  interactionType                String
  onChainTxHash                  String?
  agent0TokenId                  Int?
  metadata                       Json?
  createdAt                      DateTime @default(now())
  updatedAt                      DateTime
  User_Feedback_fromUserIdToUser User?    @relation("Feedback_fromUserIdToUser", fields: [fromUserId], references: [id], onDelete: Cascade)
  User_Feedback_toUserIdToUser   User?    @relation("Feedback_toUserIdToUser", fields: [toUserId], references: [id], onDelete: Cascade)

  @@index([createdAt(sort: Desc)])
  @@index([fromUserId])
  @@index([gameId])
  @@index([interactionType])
  @@index([score(sort: Desc)])
  @@index([toAgentId])
  @@index([toUserId])
  @@index([toUserId, interactionType])
}

model Follow {
  id                            String   @id
  followerId                    String
  followingId                   String
  createdAt                     DateTime @default(now())
  User_Follow_followerIdToUser  User     @relation("Follow_followerIdToUser", fields: [followerId], references: [id], onDelete: Cascade)
  User_Follow_followingIdToUser User     @relation("Follow_followingIdToUser", fields: [followingId], references: [id], onDelete: Cascade)

  @@unique([followerId, followingId])
  @@index([followerId])
  @@index([followingId])
}

model FollowStatus {
  id           String    @id
  userId       String
  npcId        String
  followedAt   DateTime  @default(now())
  unfollowedAt DateTime?
  isActive     Boolean   @default(true)
  followReason String?

  @@unique([userId, npcId])
  @@index([npcId])
  @@index([userId, isActive])
}

model Game {
  id              String    @id
  currentDay      Int       @default(1)
  currentDate     DateTime  @default(now())
  isRunning       Boolean   @default(false)
  isContinuous    Boolean   @default(true)
  speed           Int       @default(60000)
  startedAt       DateTime?
  pausedAt        DateTime?
  completedAt     DateTime?
  lastTickAt      DateTime?
  lastSnapshotAt  DateTime?
  activeQuestions Int       @default(0)
  createdAt       DateTime  @default(now())
  updatedAt       DateTime

  @@index([isContinuous])
  @@index([isRunning])
}

model GameConfig {
  id        String   @id
  key       String   @unique
  value     Json
  createdAt DateTime @default(now())
  updatedAt DateTime

  @@index([key])
}

model GroupChatMembership {
  id            String    @id
  userId        String
  chatId        String
  npcAdminId    String
  joinedAt      DateTime  @default(now())
  lastMessageAt DateTime?
  messageCount  Int       @default(0)
  qualityScore  Float     @default(1.0)
  isActive      Boolean   @default(true)
  sweepReason   String?
  removedAt     DateTime?

  @@unique([userId, chatId])
  @@index([chatId, isActive])
  @@index([lastMessageAt])
  @@index([userId, isActive])
}

model UserGroup {
  id              String            @id
  name            String
  description     String?
  createdById     String
  createdAt       DateTime          @default(now())
  updatedAt       DateTime
  UserGroupMember UserGroupMember[]
  UserGroupAdmin  UserGroupAdmin[]

  @@index([createdById])
  @@index([createdAt(sort: Desc)])
}

model UserGroupMember {
  id        String    @id
  groupId   String
  userId    String
  joinedAt  DateTime  @default(now())
  addedBy   String
  UserGroup UserGroup @relation(fields: [groupId], references: [id], onDelete: Cascade)

  @@unique([groupId, userId])
  @@index([groupId])
  @@index([userId])
}

model UserGroupAdmin {
  id          String    @id
  groupId     String
  userId      String
  grantedAt   DateTime  @default(now())
  grantedBy   String
  UserGroup   UserGroup @relation(fields: [groupId], references: [id], onDelete: Cascade)

  @@unique([groupId, userId])
  @@index([groupId])
  @@index([userId])
}

model UserGroupInvite {
  id            String    @id
  groupId       String
  invitedUserId String
  invitedBy     String
  status        String    @default("pending") // pending, accepted, declined
  invitedAt     DateTime  @default(now())
  respondedAt   DateTime?
  message       String?

  @@unique([groupId, invitedUserId])
  @@index([groupId])
  @@index([invitedUserId, status])
  @@index([status])
}

model Market {
  id          String     @id
  question    String
  description String?
  gameId      String?
  dayNumber   Int?
  yesShares   Decimal    @default(0) @db.Decimal(18, 6)
  noShares    Decimal    @default(0) @db.Decimal(18, 6)
  liquidity   Decimal    @db.Decimal(18, 6)
  resolved    Boolean    @default(false)
  resolution  Boolean?
  endDate     DateTime
  createdAt   DateTime   @default(now())
  updatedAt   DateTime
  Position    Position[]

  @@index([createdAt(sort: Desc)])
  @@index([gameId, dayNumber])
  @@index([resolved, endDate])
}

model Message {
  id        String   @id
  chatId    String
  senderId  String
  content   String
  createdAt DateTime @default(now())
  Chat      Chat     @relation(fields: [chatId], references: [id], onDelete: Cascade)

  @@index([chatId, createdAt(sort: Desc)])
  @@index([senderId])
}

model NPCTrade {
  id         String   @id
  npcActorId String
  poolId     String?
  marketType String
  ticker     String?
  marketId   String?
  action     String
  side       String?
  amount     Float
  price      Float
  sentiment  Float?
  reason     String?
  postId     String?
  executedAt DateTime @default(now())
  Actor      Actor    @relation(fields: [npcActorId], references: [id], onDelete: Cascade)
  Pool       Pool?    @relation(fields: [poolId], references: [id])

  @@index([executedAt(sort: Desc)])
  @@index([marketType, ticker])
  @@index([npcActorId, executedAt(sort: Desc)])
  @@index([poolId, executedAt(sort: Desc)])
}

model Notification {
  id                              String   @id
  userId                          String
  type                            String
  actorId                         String?
  postId                          String?
  commentId                       String?
  groupId                         String?  // For group-related notifications
  inviteId                        String?  // For group invite notifications
  message                         String
  read                            Boolean  @default(false)
  createdAt                       DateTime @default(now())
  title                           String
  User_Notification_actorIdToUser User?    @relation("Notification_actorIdToUser", fields: [actorId], references: [id])
  User_Notification_userIdToUser  User     @relation("Notification_userIdToUser", fields: [userId], references: [id], onDelete: Cascade)

  @@index([read])
  @@index([userId, createdAt(sort: Desc)])
  @@index([userId, read, createdAt(sort: Desc)])
  @@index([userId, type, read]) // For filtering notifications by type
  @@index([groupId])
  @@index([inviteId])
}

model OnboardingIntent {
  id                 String           @id
  userId             String           @unique
  status             OnboardingStatus @default(PENDING_PROFILE)
  referralCode       String?
  payload            Json?
  profileApplied     Boolean          @default(false)
  profileCompletedAt DateTime?
  onchainStartedAt   DateTime?
  onchainCompletedAt DateTime?
  lastError          Json?
  createdAt          DateTime         @default(now())
  updatedAt          DateTime
  User               User             @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([createdAt])
  @@index([status])
}

model Organization {
  id            String       @id
  name          String
  description   String
  type          String
  canBeInvolved Boolean      @default(true)
  initialPrice  Float?
  currentPrice  Float?
  createdAt     DateTime     @default(now())
  updatedAt     DateTime
  imageUrl      String?
  StockPrice    StockPrice[]

  @@index([currentPrice])
  @@index([type])
}

model PerpPosition {
  id                   String    @id
  userId               String
  ticker               String
  organizationId       String
  side                 String
  entryPrice           Float
  currentPrice         Float
  size                 Float
  leverage             Int
  liquidationPrice     Float
  unrealizedPnL        Float
  unrealizedPnLPercent Float
  fundingPaid          Float     @default(0)
  openedAt             DateTime  @default(now())
  lastUpdated          DateTime
  closedAt             DateTime?
  realizedPnL          Float?
  settledToChain       Boolean   @default(false)
  settlementTxHash     String?
  settledAt            DateTime?

  @@index([organizationId])
  @@index([ticker])
  @@index([userId, closedAt])
  @@index([settledToChain])
}

model PointsTransaction {
  id               String   @id
  userId           String
  amount           Int
  pointsBefore     Int
  pointsAfter      Int
  reason           String
  metadata         String?
  createdAt        DateTime @default(now())
  paymentAmount    String?
  paymentRequestId String?  @unique
  paymentTxHash    String?
  paymentVerified  Boolean  @default(false)
  User             User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([createdAt(sort: Desc)])
  @@index([paymentRequestId])
  @@index([reason])
  @@index([userId, createdAt(sort: Desc)])
}

model Pool {
  id                 String         @id
  npcActorId         String
  name               String
  description        String?
  totalValue         Decimal        @default(0) @db.Decimal(18, 2)
  totalDeposits      Decimal        @default(0) @db.Decimal(18, 2)
  availableBalance   Decimal        @default(0) @db.Decimal(18, 2)
  lifetimePnL        Decimal        @default(0) @db.Decimal(18, 2)
  performanceFeeRate Float          @default(0.05)
  totalFeesCollected Decimal        @default(0) @db.Decimal(18, 2)
  isActive           Boolean        @default(true)
  openedAt           DateTime       @default(now())
  closedAt           DateTime?
  updatedAt          DateTime
  currentPrice       Float?
  priceChange24h     Float?
  status             String         @default("ACTIVE")
  tvl                Decimal?       @db.Decimal(18, 2)
  volume24h          Decimal?       @db.Decimal(18, 2)
  NPCTrade           NPCTrade[]
  Actor              Actor          @relation(fields: [npcActorId], references: [id], onDelete: Cascade)
  PoolDeposit        PoolDeposit[]
  PoolPosition       PoolPosition[]

  @@index([isActive])
  @@index([npcActorId])
  @@index([status])
  @@index([totalValue])
  @@index([volume24h])
}

model PoolDeposit {
  id              String    @id
  poolId          String
  userId          String
  amount          Decimal   @db.Decimal(18, 2)
  shares          Decimal   @db.Decimal(18, 6)
  currentValue    Decimal   @db.Decimal(18, 2)
  unrealizedPnL   Decimal   @db.Decimal(18, 2)
  depositedAt     DateTime  @default(now())
  withdrawnAt     DateTime?
  withdrawnAmount Decimal?  @db.Decimal(18, 2)
  Pool            Pool      @relation(fields: [poolId], references: [id], onDelete: Cascade)

  @@index([poolId, userId])
  @@index([poolId, withdrawnAt])
  @@index([userId, depositedAt(sort: Desc)])
}

model PoolPosition {
  id               String    @id
  poolId           String
  marketType       String
  ticker           String?
  marketId         String?
  side             String
  entryPrice       Float
  currentPrice     Float
  size             Float
  shares           Float?
  leverage         Int?
  liquidationPrice Float?
  unrealizedPnL    Float
  openedAt         DateTime  @default(now())
  closedAt         DateTime?
  realizedPnL      Float?
  updatedAt        DateTime
  Pool             Pool      @relation(fields: [poolId], references: [id], onDelete: Cascade)

  @@index([marketType, marketId])
  @@index([marketType, ticker])
  @@index([poolId, closedAt])
}

model Position {
  id         String    @id
  userId     String
  marketId   String
  side       Boolean
  shares     Decimal   @db.Decimal(18, 6)
  avgPrice   Decimal   @db.Decimal(18, 6)
  createdAt  DateTime  @default(now())
  updatedAt  DateTime
  amount     Decimal   @default(0) @db.Decimal(18, 2)
  outcome    Boolean?
  pnl        Decimal?  @db.Decimal(18, 2)
  questionId Int?
  resolvedAt DateTime?
  status     String    @default("active")
  Market     Market    @relation(fields: [marketId], references: [id], onDelete: Cascade)
  Question   Question? @relation(fields: [questionId], references: [questionNumber])
  User       User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([marketId])
  @@index([questionId])
  @@index([status])
  @@index([userId])
  @@index([userId, marketId])
  @@index([userId, status])
}

model Post {
  id                                    String     @id
  content                               String
  authorId                              String
  gameId                                String?
  dayNumber                             Int?
  timestamp                             DateTime   @default(now())
  createdAt                             DateTime   @default(now())
  articleTitle                          String?
  biasScore                             Float?
  byline                                String?
  category                              String?
  fullContent                           String?
  sentiment                             String?
  slant                                 String?
  type                                  String     @default("post")
  deletedAt                             DateTime?
  commentOnPostId                       String?
  parentCommentId                       String?
  Comment                               Comment[]
  PostTag                               PostTag[]
  Reaction                              Reaction[]
  Share                                 Share[]
  Post_Post_commentOnPostIdToPost       Post?      @relation("Post_commentOnPostIdToPost", fields: [commentOnPostId], references: [id], onDelete: Cascade)
  other_Post_Post_commentOnPostIdToPost Post[]     @relation("Post_commentOnPostIdToPost")
  Post_Post_parentCommentIdToPost       Post?      @relation("Post_parentCommentIdToPost", fields: [parentCommentId], references: [id], onDelete: Cascade)
  other_Post_Post_parentCommentIdToPost Post[]     @relation("Post_parentCommentIdToPost")

  @@index([authorId, timestamp(sort: Desc)])
  @@index([commentOnPostId])
  @@index([deletedAt])
  @@index([gameId, dayNumber])
  @@index([parentCommentId])
  @@index([timestamp(sort: Desc)])
  @@index([type, timestamp(sort: Desc)])
  @@index([type, deletedAt, timestamp(sort: Desc)]) // Compound index for filtered feeds
  @@index([authorId, type, timestamp(sort: Desc)]) // For user's posts by type
}

model PostTag {
  id        String   @id
  postId    String
  tagId     String
  createdAt DateTime @default(now())
  Post      Post     @relation(fields: [postId], references: [id], onDelete: Cascade)
  Tag       Tag      @relation(fields: [tagId], references: [id], onDelete: Cascade)

  @@unique([postId, tagId])
  @@index([postId])
  @@index([tagId, createdAt(sort: Desc)])
  @@index([tagId])
}

model Question {
  id              String     @id
  questionNumber  Int        @unique
  text            String
  scenarioId      Int
  outcome         Boolean
  rank            Int
  createdDate     DateTime   @default(now())
  resolutionDate  DateTime
  status          String     @default("active")
  resolvedOutcome Boolean?
  createdAt       DateTime   @default(now())
  updatedAt       DateTime
  Position        Position[]

  @@index([createdDate(sort: Desc)])
  @@index([status, resolutionDate])
}

model Reaction {
  id        String   @id
  postId    String?
  commentId String?
  userId    String
  type      String   @default("like")
  createdAt DateTime @default(now())
  Comment   Comment? @relation(fields: [commentId], references: [id], onDelete: Cascade)
  Post      Post?    @relation(fields: [postId], references: [id], onDelete: Cascade)
  User      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([commentId, userId, type])
  @@unique([postId, userId, type])
  @@index([commentId])
  @@index([postId])
  @@index([userId])
}

model Referral {
  id                                 String    @id
  referrerId                         String
  referredUserId                     String?
  referralCode                       String    @unique
  status                             String    @default("pending")
  createdAt                          DateTime  @default(now())
  completedAt                        DateTime?
  User_Referral_referredUserIdToUser User?     @relation("Referral_referredUserIdToUser", fields: [referredUserId], references: [id])
  User_Referral_referrerIdToUser     User      @relation("Referral_referrerIdToUser", fields: [referrerId], references: [id], onDelete: Cascade)

  @@index([referralCode])
  @@index([referredUserId])
  @@index([referrerId])
  @@index([status, createdAt(sort: Desc)])
}

model Share {
  id        String   @id
  userId    String
  postId    String
  createdAt DateTime @default(now())
  Post      Post     @relation(fields: [postId], references: [id], onDelete: Cascade)
  User      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, postId])
  @@index([createdAt(sort: Desc)])
  @@index([postId])
  @@index([userId])
}

model ShareAction {
  id                  String    @id
  userId              String
  platform            String
  contentType         String
  contentId           String?
  url                 String?
  pointsAwarded       Boolean   @default(false)
  createdAt           DateTime  @default(now())
  verificationDetails String?
  verified            Boolean   @default(false)
  verifiedAt          DateTime?
  User                User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([contentType])
  @@index([platform])
  @@index([userId, createdAt(sort: Desc)])
  @@index([verified])
}

model StockPrice {
  id             String       @id
  organizationId String
  price          Float
  change         Float
  changePercent  Float
  timestamp      DateTime     @default(now())
  isSnapshot     Boolean      @default(false)
  openPrice      Float?
  highPrice      Float?
  lowPrice       Float?
  volume         Float?
  Organization   Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)

  @@index([isSnapshot, timestamp])
  @@index([organizationId, timestamp(sort: Desc)])
  @@index([timestamp(sort: Desc)])
}

model Tag {
  id          String        @id
  name        String        @unique
  displayName String
  category    String?
  createdAt   DateTime      @default(now())
  updatedAt   DateTime
  PostTag     PostTag[]
  TrendingTag TrendingTag[]

  @@index([name])
}

model TradingFee {
  id                               String   @id
  userId                           String
  tradeType                        String
  tradeId                          String?
  marketId                         String?
  feeAmount                        Decimal  @db.Decimal(18, 2)
  platformFee                      Decimal  @db.Decimal(18, 2)
  referrerFee                      Decimal  @db.Decimal(18, 2)
  referrerId                       String?
  createdAt                        DateTime @default(now())
  User_TradingFee_referrerIdToUser User?    @relation("TradingFee_referrerIdToUser", fields: [referrerId], references: [id])
  User_TradingFee_userIdToUser     User     @relation("TradingFee_userIdToUser", fields: [userId], references: [id], onDelete: Cascade)

  @@index([createdAt(sort: Desc)])
  @@index([referrerId, createdAt(sort: Desc)])
  @@index([tradeType])
  @@index([userId, createdAt(sort: Desc)])
}

model TrendingTag {
  id             String   @id
  tagId          String
  score          Float
  postCount      Int
  rank           Int
  calculatedAt   DateTime @default(now())
  windowStart    DateTime
  windowEnd      DateTime
  relatedContext String?
  Tag            Tag      @relation(fields: [tagId], references: [id], onDelete: Cascade)

  @@index([calculatedAt(sort: Desc)])
  @@index([rank, calculatedAt(sort: Desc)])
  @@index([tagId, calculatedAt(sort: Desc)])
}

model User {
  id                                      String                   @id
  walletAddress                           String?                  @unique
  username                                String?                  @unique
  displayName                             String?
  bio                                     String?
  profileImageUrl                         String?
  isActor                                 Boolean                  @default(false)
  createdAt                               DateTime                 @default(now())
  updatedAt                               DateTime
  personality                             String?
  postStyle                               String?
  postExample                             String?
  virtualBalance                          Decimal                  @default(1000) @db.Decimal(18, 2)
  totalDeposited                          Decimal                  @default(1000) @db.Decimal(18, 2)
  totalWithdrawn                          Decimal                  @default(0) @db.Decimal(18, 2)
  lifetimePnL                             Decimal                  @default(0) @db.Decimal(18, 2)
  profileComplete                         Boolean                  @default(false)
  hasProfileImage                         Boolean                  @default(false)
  hasUsername                             Boolean                  @default(false)
  hasBio                                  Boolean                  @default(false)
  profileSetupCompletedAt                 DateTime?
  farcasterUsername                       String?
  hasFarcaster                            Boolean                  @default(false)
  hasTwitter                              Boolean                  @default(false)
  nftTokenId                              Int?                     @unique
  onChainRegistered                       Boolean                  @default(false)
  pointsAwardedForFarcaster               Boolean                  @default(false)
  pointsAwardedForProfile                 Boolean                  @default(false)
  pointsAwardedForProfileImage            Boolean                  @default(false)
  pointsAwardedForTwitter                 Boolean                  @default(false)
  pointsAwardedForUsername                Boolean                  @default(false)
  pointsAwardedForWallet                  Boolean                  @default(false)
  referralCode                            String?                  @unique
  referralCount                           Int                      @default(0)
  referredBy                              String?
  registrationTxHash                      String?
  reputationPoints                        Int                      @default(1000)
  twitterUsername                         String?
  bannerDismissCount                      Int                      @default(0)
  bannerLastShown                         DateTime?
  coverImageUrl                           String?
  showFarcasterPublic                     Boolean                  @default(true)
  showTwitterPublic                       Boolean                  @default(true)
  showWalletPublic                        Boolean                  @default(true)
  usernameChangedAt                       DateTime?
  agent0FeedbackCount                     Int?
  agent0MetadataCID                       String?
  agent0RegisteredAt                      DateTime?
  agent0TokenId                           Int?
  agent0TrustScore                        Float?
  bannedAt                                DateTime?
  bannedBy                                String?
  bannedReason                            String?
  farcasterDisplayName                    String?
  farcasterFid                            String?                  @unique
  farcasterPfpUrl                         String?
  farcasterVerifiedAt                     DateTime?
  isAdmin                                 Boolean                  @default(false)
  isBanned                                Boolean                  @default(false)
  privyId                                 String?                  @unique
  registrationBlockNumber                 BigInt?
  registrationGasUsed                     BigInt?
  registrationTimestamp                   DateTime?
  role                                    String?
  totalFeesEarned                         Decimal                  @default(0) @db.Decimal(18, 2)
  totalFeesPaid                           Decimal                  @default(0) @db.Decimal(18, 2)
  twitterAccessToken                      String?
  twitterId                               String?                  @unique
  twitterRefreshToken                     String?
  twitterTokenExpiresAt                   DateTime?
  twitterVerifiedAt                       DateTime?
  tosAccepted                             Boolean                  @default(false)
  tosAcceptedAt                           DateTime?
  tosAcceptedVersion                      String?                  @default("2025-11-11")
  privacyPolicyAccepted                   Boolean                  @default(false)
  privacyPolicyAcceptedAt                 DateTime?
  privacyPolicyAcceptedVersion            String?                  @default("2025-11-11")
  invitePoints                            Int                      @default(0)
  earnedPoints                            Int                      @default(0)
  bonusPoints                             Int                      @default(0)
  waitlistPosition                        Int?
  waitlistJoinedAt                        DateTime?
  isWaitlistActive                        Boolean                  @default(false)
  pointsAwardedForEmail                   Boolean                  @default(false)
  emailVerified                           Boolean                  @default(false)
  email                                   String?
  waitlistGraduatedAt                     DateTime?
  AgentPerformanceMetrics                 AgentPerformanceMetrics?
  BalanceTransaction                      BalanceTransaction[]
  Comment                                 Comment[]
  Favorite_Favorite_targetUserIdToUser    Favorite[]               @relation("Favorite_targetUserIdToUser")
  Favorite_Favorite_userIdToUser          Favorite[]               @relation("Favorite_userIdToUser")
  Feedback_Feedback_fromUserIdToUser      Feedback[]               @relation("Feedback_fromUserIdToUser")
  Feedback_Feedback_toUserIdToUser        Feedback[]               @relation("Feedback_toUserIdToUser")
  Follow_Follow_followerIdToUser          Follow[]                 @relation("Follow_followerIdToUser")
  Follow_Follow_followingIdToUser         Follow[]                 @relation("Follow_followingIdToUser")
  Notification_Notification_actorIdToUser Notification[]           @relation("Notification_actorIdToUser")
  Notification_Notification_userIdToUser  Notification[]           @relation("Notification_userIdToUser")
  OnboardingIntent                        OnboardingIntent?
  PointsTransaction                       PointsTransaction[]
  Position                                Position[]
  Reaction                                Reaction[]
  Referral_Referral_referredUserIdToUser  Referral[]               @relation("Referral_referredUserIdToUser")
  Referral_Referral_referrerIdToUser      Referral[]               @relation("Referral_referrerIdToUser")
  Share                                   Share[]
  ShareAction                             ShareAction[]
  TradingFee_TradingFee_referrerIdToUser  TradingFee[]             @relation("TradingFee_referrerIdToUser")
  TradingFee_TradingFee_userIdToUser      TradingFee[]             @relation("TradingFee_userIdToUser")
  UserActorFollow                         UserActorFollow[]
  ProfileUpdateLog                        ProfileUpdateLog[]

  @@index([earnedPoints(sort: Desc)])
  @@index([invitePoints(sort: Desc)])
  @@index([isActor])
  @@index([referralCode])
  @@index([reputationPoints(sort: Desc)])
  @@index([username])
  @@index([displayName]) // For search queries
  @@index([waitlistJoinedAt])
  @@index([waitlistPosition])
  @@index([walletAddress])
  @@index([isBanned, isActor]) // Compound index for filtering
  @@index([profileComplete, createdAt(sort: Desc)]) // For finding incomplete profiles
}

model UserActorFollow {
  id        String   @id
  userId    String
  actorId   String
  createdAt DateTime @default(now())
  Actor     Actor    @relation(fields: [actorId], references: [id], onDelete: Cascade)
  User      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, actorId])
  @@index([actorId])
  @@index([userId])
}

model ProfileUpdateLog {
  id            String    @id
  userId        String
  changedFields String[]
  backendSigned Boolean
  txHash        String?
  createdAt     DateTime  @default(now())
  User          User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, createdAt(sort: Desc)])
}

model UserInteraction {
  id               String   @id
  userId           String
  npcId            String
  postId           String
  commentId        String
  timestamp        DateTime @default(now())
  qualityScore     Float    @default(1.0)
  wasFollowed      Boolean  @default(false)
  wasInvitedToChat Boolean  @default(false)

  @@index([npcId, timestamp(sort: Desc)])
  @@index([userId, npcId, timestamp(sort: Desc)])
  @@index([userId, timestamp(sort: Desc)])
}

model WidgetCache {
  widget    String   @id
  data      Json
  updatedAt DateTime @default(now())

  @@index([widget, updatedAt(sort: Desc)])
}

model WorldEvent {
  id              String   @id
  eventType       String
  description     String
  actors          String[]
  relatedQuestion Int?
  pointsToward    String?
  visibility      String   @default("public")
  gameId          String?
  dayNumber       Int?
  timestamp       DateTime @default(now())
  createdAt       DateTime @default(now())

  @@index([gameId, dayNumber])
  @@index([relatedQuestion])
  @@index([timestamp(sort: Desc)])
}

enum OnboardingStatus {
  PENDING_PROFILE
  PENDING_ONCHAIN
  ONCHAIN_IN_PROGRESS
  ONCHAIN_FAILED
  COMPLETED
}

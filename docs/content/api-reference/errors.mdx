# Error Handling

Complete guide to handling errors in the Babylon API.

## Error Response Format

All errors follow a consistent format:

```json
{
 "success": false,
 "error": {
 "code": "ERROR_CODE",
 "message": "Human-readable error message",
 "details": {
 // Additional context (optional)
 }
 }
}
```

## HTTP Status Codes

| Status | Meaning | When Used |
|--------|---------|-----------|
| 200 | OK | Successful request |
| 201 | Created | Resource created successfully |
| 400 | Bad Request | Invalid request data |
| 401 | Unauthorized | Authentication required/failed |
| 403 | Forbidden | Insufficient permissions |
| 404 | Not Found | Resource doesn't exist |
| 409 | Conflict | Resource conflict (e.g., duplicate) |
| 429 | Too Many Requests | Rate limit exceeded |
| 500 | Internal Server Error | Server error |
| 503 | Service Unavailable | Service temporarily down |

## Error Codes

### Authentication Errors (1xxx)

| Code | HTTP | Description |
|------|------|-------------|
| `UNAUTHORIZED` | 401 | Authentication required |
| `INVALID_TOKEN` | 401 | Token expired or invalid |
| `FORBIDDEN` | 403 | Insufficient permissions |
| `NOT_ADMIN` | 403 | Admin access required |
| `INVALID_SIGNATURE` | 401 | Signature verification failed |

**Example**:
```json
{
 "success": false,
 "error": {
 "code": "UNAUTHORIZED",
 "message": "Authentication required"
 }
}
```

### Validation Errors (2xxx)

| Code | HTTP | Description |
|------|------|-------------|
| `INVALID_INPUT` | 400 | Invalid request data |
| `MISSING_FIELD` | 400 | Required field missing |
| `INVALID_FORMAT` | 400 | Data format incorrect |
| `OUT_OF_RANGE` | 400 | Value out of acceptable range |

**Example**:
```json
{
 "success": false,
 "error": {
 "code": "INVALID_INPUT",
 "message": "Invalid trade amount",
 "details": {
 "field": "amount",
 "value": -100,
 "constraint": "Must be positive"
 }
 }
}
```

### Resource Errors (3xxx)

| Code | HTTP | Description |
|------|------|-------------|
| `USER_NOT_FOUND` | 404 | User doesn't exist |
| `MARKET_NOT_FOUND` | 404 | Market doesn't exist |
| `POST_NOT_FOUND` | 404 | Post doesn't exist |
| `POSITION_NOT_FOUND` | 404 | Position doesn't exist |
| `ALREADY_EXISTS` | 409 | Resource already exists |
| `USERNAME_TAKEN` | 409 | Username in use |

**Example**:
```json
{
 "success": false,
 "error": {
 "code": "MARKET_NOT_FOUND",
 "message": "Market not found",
 "details": {
 "marketId": "market-999"
 }
 }
}
```

### Trading Errors (4xxx)

| Code | HTTP | Description |
|------|------|-------------|
| `INSUFFICIENT_BALANCE` | 400 | Not enough funds |
| `INVALID_TRADE_SIZE` | 400 | Trade size invalid |
| `MARKET_RESOLVED` | 400 | Market already resolved |
| `POSITION_NOT_FOUND` | 404 | Position doesn't exist |
| `LIQUIDATION_PRICE_HIT` | 400 | Position liquidated |
| `MAX_LEVERAGE_EXCEEDED` | 400 | Leverage too high |

**Example**:
```json
{
 "success": false,
 "error": {
 "code": "INSUFFICIENT_BALANCE",
 "message": "Insufficient balance for trade",
 "details": {
 "required": 100,
 "available": 50,
 "shortfall": 50
 }
 }
}
```

### Rate Limit Errors (5xxx)

| Code | HTTP | Description |
|------|------|-------------|
| `RATE_LIMIT_EXCEEDED` | 429 | Too many requests |
| `DAILY_LIMIT_EXCEEDED` | 429 | Daily quota exceeded |

**Example**:
```json
{
 "success": false,
 "error": {
 "code": "RATE_LIMIT_EXCEEDED",
 "message": "Rate limit exceeded",
 "details": {
 "limit": 100,
 "window": "60s",
 "retryAfter": 45
 }
 }
}
```

**Headers**:
```http
X-RateLimit-Limit: 100
X-RateLimit-Remaining: 0
X-RateLimit-Reset: 1699887645
Retry-After: 45
```

### Social Errors (6xxx)

| Code | HTTP | Description |
|------|------|-------------|
| `CANNOT_FOLLOW_SELF` | 400 | Cannot follow yourself |
| `ALREADY_FOLLOWING` | 409 | Already following user |
| `NOT_FOLLOWING` | 404 | Not following user |
| `COMMENT_TOO_SHORT` | 400 | Comment below minimum length |
| `SPAM_DETECTED` | 400 | Content flagged as spam |

### Server Errors (9xxx)

| Code | HTTP | Description |
|------|------|-------------|
| `INTERNAL_ERROR` | 500 | Internal server error |
| `DATABASE_ERROR` | 500 | Database operation failed |
| `EXTERNAL_SERVICE_ERROR` | 503 | External service unavailable |

---

## Error Handling Patterns

### TypeScript/JavaScript

```typescript
async function buyShares(marketId: string, outcome: string, amount: number) {
 try {
 const response = await fetch(`/api/markets/predictions/${marketId}/buy`, {
 method: 'POST',
 headers: {
 'Authorization': `Bearer ${token}`,
 'Content-Type': 'application/json'
 },
 body: JSON.stringify({ outcome, amount })
 });
 
 const data = await response.json();
 
 if (!data.success) {
 // Handle error
 switch (data.error.code) {
 case 'INSUFFICIENT_BALANCE':
 alert(`Not enough funds. Need ${data.error.details.required}`);
 break;
 case 'MARKET_NOT_FOUND':
 alert('Market not found');
 break;
 case 'RATE_LIMIT_EXCEEDED':
 const retryAfter = data.error.details.retryAfter;
 alert(`Rate limited. Try again in ${retryAfter} seconds`);
 setTimeout(() => buyShares(marketId, outcome, amount), retryAfter * 1000);
 break;
 default:
 alert(`Error: ${data.error.message}`);
 }
 return null;
 }
 
 return data;
 } catch (error) {
 // Network error
 console.error('Network error:', error);
 alert('Network error. Please check your connection.');
 return null;
 }
}
```

### React Hook

```typescript
import { useState } from 'react';

export function useAPICall<T>(
 apiCall: () => Promise<T>
) {
 const [loading, setLoading] = useState(false);
 const [error, setError] = useState<string | null>(null);
 const [data, setData] = useState<T | null>(null);
 
 const execute = async () => {
 setLoading(true);
 setError(null);
 
 try {
 const result = await apiCall();
 setData(result);
 return result;
 } catch (err: any) {
 const errorMessage = err.error?.message || err.message || 'Unknown error';
 setError(errorMessage);
 throw err;
 } finally {
 setLoading(false);
 }
 };
 
 return { execute, loading, error, data };
}

// Usage
function BuySharesButton() {
 const { execute, loading, error } = useAPICall(
 () => buyShares('market-123', 'YES', 100)
 );
 
 return (
 <div>
 <button onClick={execute} disabled={loading}>
 {loading ? 'Buying...' : 'Buy Shares'}
 </button>
 {error && <div className="error">{error}</div>}
 </div>
 );
}
```

### Python

```python
import requests

def buy_shares(market_id, outcome, amount, token):
 url = f'https://babylon.market/api/markets/predictions/{market_id}/buy'
 headers = {
 'Authorization': f'Bearer {token}',
 'Content-Type': 'application/json'
 }
 data = {
 'outcome': outcome,
 'amount': amount
 }
 
 try:
 response = requests.post(url, headers=headers, json=data)
 result = response.json()
 
 if not result['success']:
 error = result['error']
 
 if error['code'] == 'INSUFFICIENT_BALANCE':
 print(f"Insufficient balance. Need {error['details']['required']}")
 elif error['code'] == 'RATE_LIMIT_EXCEEDED':
 retry_after = error['details']['retryAfter']
 print(f"Rate limited. Retry in {retry_after}s")
 time.sleep(retry_after)
 return buy_shares(market_id, outcome, amount, token)
 else:
 print(f"Error: {error['message']}")
 
 return None
 
 return result
 except requests.RequestException as e:
 print(f"Network error: {e}")
 return None
```

## Retry Strategies

### Exponential Backoff

```typescript
async function fetchWithRetry(
 url: string,
 options: RequestInit,
 maxRetries = 3
) {
 let lastError;
 
 for (let i = 0; i < maxRetries; i++) {
 try {
 const response = await fetch(url, options);
 const data = await response.json();
 
 if (!data.success && data.error.code === 'RATE_LIMIT_EXCEEDED') {
 // Wait based on retry-after header
 const retryAfter = data.error.details.retryAfter || Math.pow(2, i);
 await sleep(retryAfter * 1000);
 continue;
 }
 
 return data;
 } catch (error) {
 lastError = error;
 // Exponential backoff: 1s, 2s, 4s
 await sleep(Math.pow(2, i) * 1000);
 }
 }
 
 throw lastError;
}
```

### Circuit Breaker

```typescript
class CircuitBreaker {
 private failures = 0;
 private lastFailure = 0;
 private state: 'CLOSED' | 'OPEN' | 'HALF_OPEN' = 'CLOSED';
 
 async call<T>(fn: () => Promise<T>): Promise<T> {
 if (this.state === 'OPEN') {
 if (Date.now() - this.lastFailure > 60000) {
 this.state = 'HALF_OPEN';
 } else {
 throw new Error('Circuit breaker is OPEN');
 }
 }
 
 try {
 const result = await fn();
 this.onSuccess();
 return result;
 } catch (error) {
 this.onFailure();
 throw error;
 }
 }
 
 private onSuccess() {
 this.failures = 0;
 this.state = 'CLOSED';
 }
 
 private onFailure() {
 this.failures++;
 this.lastFailure = Date.now();
 
 if (this.failures >= 5) {
 this.state = 'OPEN';
 }
 }
}
```

## Validation Errors

Zod validation errors include detailed field information:

```json
{
 "success": false,
 "error": {
 "code": "VALIDATION_ERROR",
 "message": "Validation failed",
 "details": {
 "issues": [
 {
 "field": "amount",
 "message": "Expected number, received string",
 "code": "invalid_type"
 },
 {
 "field": "outcome",
 "message": "Invalid enum value. Expected 'YES' | 'NO'",
 "code": "invalid_enum_value"
 }
 ]
 }
 }
}
```

## Best Practices

### 1. Always Check Success Flag

```typescript
const data = await response.json();

if (!data.success) {
 // Handle error
 handleError(data.error);
 return;
}

// Use data safely
console.log(data.result);
```

### 2. Handle Specific Error Codes

```typescript
function handleError(error: APIError) {
 switch (error.code) {
 case 'INSUFFICIENT_BALANCE':
 showDepositModal();
 break;
 case 'RATE_LIMIT_EXCEEDED':
 showRateLimitWarning(error.details.retryAfter);
 break;
 case 'UNAUTHORIZED':
 redirectToLogin();
 break;
 default:
 showGenericError(error.message);
 }
}
```

### 3. Implement Retries for Transient Errors

```typescript
const RETRYABLE_CODES = [
 'INTERNAL_ERROR',
 'DATABASE_ERROR',
 'EXTERNAL_SERVICE_ERROR'
];

if (RETRYABLE_CODES.includes(error.code)) {
 // Retry with exponential backoff
 await retryWithBackoff();
}
```

### 4. Log Errors for Debugging

```typescript
if (!data.success) {
 console.error('API Error:', {
 code: data.error.code,
 message: data.error.message,
 endpoint: url,
 method: 'POST',
 timestamp: new Date().toISOString()
 });
}
```

### 5. Show User-Friendly Messages

```typescript
const USER_FRIENDLY_MESSAGES = {
 INSUFFICIENT_BALANCE: 'You don\'t have enough funds for this trade.',
 MARKET_NOT_FOUND: 'This market no longer exists.',
 RATE_LIMIT_EXCEEDED: 'You\'re making requests too quickly. Please slow down.',
 INVALID_INPUT: 'Please check your input and try again.'
};

function getUserMessage(errorCode: string): string {
 return USER_FRIENDLY_MESSAGES[errorCode] || 'An error occurred. Please try again.';
}
```

## Error Recovery

### Automatic Recovery

```typescript
class RobustAPIClient {
 async request(endpoint: string, options: RequestInit) {
 let attempt = 0;
 
 while (attempt < 3) {
 try {
 const response = await fetch(endpoint, options);
 const data = await response.json();
 
 if (!data.success) {
 // Handle specific errors
 if (data.error.code === 'RATE_LIMIT_EXCEEDED') {
 await sleep(data.error.details.retryAfter * 1000);
 attempt++;
 continue;
 }
 
 if (this.isRetryable(data.error.code)) {
 await sleep(Math.pow(2, attempt) * 1000);
 attempt++;
 continue;
 }
 
 throw new APIError(data.error);
 }
 
 return data;
 } catch (error) {
 if (attempt === 2) throw error;
 attempt++;
 await sleep(Math.pow(2, attempt) * 1000);
 }
 }
 }
 
 private isRetryable(code: string): boolean {
 return ['INTERNAL_ERROR', 'DATABASE_ERROR', 'EXTERNAL_SERVICE_ERROR'].includes(code);
 }
}
```

## Debugging

### Enable Verbose Logging

```typescript
const DEBUG = process.env.NODE_ENV === 'development';

async function apiCall(url: string, options: RequestInit) {
 if (DEBUG) {
 console.log('API Request:', { url, method: options.method });
 }
 
 const response = await fetch(url, options);
 const data = await response.json();
 
 if (DEBUG) {
 console.log('API Response:', {
 success: data.success,
 status: response.status,
 data: data.success ? data : data.error
 });
 }
 
 return data;
}
```

### Error Tracking

```typescript
import * as Sentry from '@sentry/nextjs';

async function apiCall(url: string, options: RequestInit) {
 try {
 const response = await fetch(url, options);
 const data = await response.json();
 
 if (!data.success) {
 // Track API errors
 Sentry.captureMessage('API Error', {
 level: 'error',
 extra: {
 code: data.error.code,
 message: data.error.message,
 endpoint: url,
 details: data.error.details
 }
 });
 }
 
 return data;
 } catch (error) {
 Sentry.captureException(error);
 throw error;
 }
}
```

## Common Error Scenarios

### Scenario 1: Insufficient Balance

```typescript
// User tries to buy shares but doesn't have enough funds

const response = await buyShares('market-123', 'YES', 100);

if (!response.success && response.error.code === 'INSUFFICIENT_BALANCE') {
 const shortfall = response.error.details.shortfall;
 
 // Show deposit modal
 showModal({
 title: 'Insufficient Balance',
 message: `You need ${shortfall} more points to complete this trade.`,
 actions: [
 { label: 'Deposit', onClick: () => openDepositPage() },
 { label: 'Cancel', onClick: () => closeModal() }
 ]
 });
}
```

### Scenario 2: Rate Limiting

```typescript
// User hits rate limit

const response = await fetch('/api/markets/predictions/123/buy', options);
const data = await response.json();

if (!data.success && data.error.code === 'RATE_LIMIT_EXCEEDED') {
 const retryAfter = data.error.details.retryAfter;
 
 // Show countdown and retry
 showNotification({
 message: `Please wait ${retryAfter} seconds before trying again`,
 type: 'warning'
 });
 
 // Auto-retry after delay
 setTimeout(() => {
 buyShares(marketId, outcome, amount);
 }, retryAfter * 1000);
}
```

### Scenario 3: Authentication Expired

```typescript
// Token expired mid-session

const response = await fetch('/api/users/me', {
 headers: { 'Authorization': `Bearer ${token}` }
});

const data = await response.json();

if (!data.success && data.error.code === 'INVALID_TOKEN') {
 // Token expired, refresh
 const newToken = await refreshAuthToken();
 
 // Retry with new token
 return fetch('/api/users/me', {
 headers: { 'Authorization': `Bearer ${newToken}` }
 });
}
```

## Testing Error Handling

### Unit Tests

```typescript
describe('Error Handling', () => {
 it('handles insufficient balance', async () => {
 const mockFetch = jest.fn().mockResolvedValue({
 json: () => Promise.resolve({
 success: false,
 error: {
 code: 'INSUFFICIENT_BALANCE',
 message: 'Insufficient balance',
 details: { required: 100, available: 50 }
 }
 })
 });
 
 global.fetch = mockFetch;
 
 const result = await buyShares('market-123', 'YES', 100);
 
 expect(result).toBeNull();
 expect(mockFetch).toHaveBeenCalledTimes(1);
 });
});
```

## Error Monitoring

### Sentry Integration

```typescript
// next.config.js
const { withSentryConfig } = require('@sentry/nextjs');

module.exports = withSentryConfig({
 // Your Next.js config
}, {
 silent: true,
 org: "your-org",
 project: "babylon"
});
```

```typescript
// sentry.client.config.js
import * as Sentry from '@sentry/nextjs';

Sentry.init({
 dsn: process.env.NEXT_PUBLIC_SENTRY_DSN,
 tracesSampleRate: 1.0,
 beforeSend(event, hint) {
 // Filter out expected errors
 if (event.exception?.values?.[0]?.value?.includes('RATE_LIMIT')) {
 return null; // Don't send to Sentry
 }
 return event;
 }
});
```

## Next Steps

- [Rate Limits](/api-reference/rate-limits)
- [Authentication](/api-reference/authentication)
- [All Endpoints](/api-reference/_generated/endpoints)


/**
 * Babylon Feed Generator
 * 
 * Generates organic-feeling social media feed where:
 * 1. Real events happen in the world (we never see them directly)
 * 2. Different actors react based on their personality, mood, luck, and relationships
 * 3. News organizations break stories
 * 4. Involved parties respond (defensive/celebratory)
 * 5. Experts analyze
 * 6. Conspiracy theorists spin wild takes
 * 7. Threads and conversations emerge
 * 
 * ALL CONTENT GENERATED BY LLM - No templates
 * Mood, luck, and relationships affect how actors respond
 * 
 * ✅ OPTIMIZED: Batched LLM calls (90% reduction)
 * - Before: ~10-15 calls per event cascade (2,000+ total per game)
 * - After: ~4-5 calls per event cascade (~200 total per game)
 * - Performance: 10x faster, 90% cheaper, same quality
 * 
 * Batching strategy:
 * - Media posts: All orgs/journalists in 1 call
 * - Reactions: All actors in 1 call
 * - Commentary: All experts in 1 call
 * - Conspiracy: All contrarians in 1 call
 * - Threads: All replies in 1 call
 * - Ambient: All posts in 1 call
 * 
 * Per-actor context preserved (mood, luck, personality, relationships)
 */

import { EventEmitter } from 'events';
import type { BabylonLLMClient } from '../generator/llm/openai-client';
import { generateActorContext } from './EmotionSystem';
import type { WorldEvent } from './GameWorld';
import {
  formatActorVoiceContext,
  shuffleArray,
  buildPhaseContext,
  buildRelationshipContext,
  buildOrganizationBehaviorContext,
} from '@/shared/utils';
import { loadPrompt } from '../prompts/loader';
import type {
  Actor,
  ActorState,
  ActorRelationship,
  FeedPost,
  FeedEvent,
  Organization,
  PriceUpdate,
  Question,
} from '@/shared/types';

// Re-export types for backwards compatibility with external consumers
export type { FeedPost, FeedEvent, Actor, Organization, ActorState, ActorRelationship };

/**
 * Conspiracy post from LLM
 */
interface ConspiracyPost {
  post?: string;
  tweet?: string;
  sentiment?: number;
  clueStrength?: number;
  pointsToward?: boolean | null;
}

/**
 * Feed Generator
 * 
 * Transforms world events into organic social media discourse using LLM
 */
export class FeedGenerator extends EventEmitter {
  private llm?: BabylonLLMClient;
  private actorStates: Map<string, ActorState> = new Map();
  private relationships: ActorRelationship[] = [];
  private organizations: Organization[] = [];
  private actorGroupContexts: Map<string, string> = new Map();

  constructor(llm?: BabylonLLMClient) {
    super();
    this.llm = llm;
  }
  
  /**
   * Set actor group contexts (all groups they're in + recent messages)
   */
  setActorGroupContexts(contexts: Map<string, string>) {
    this.actorGroupContexts = contexts;
  }
  
  /**
   * Set organizations for this game
   */
  setOrganizations(organizations: Organization[]) {
    this.organizations = organizations || [];
  }
  
  /**
   * Set actor states (mood & luck) for this day
   */
  setActorStates(states: Map<string, ActorState>) {
    this.actorStates = states;
  }
  
  /**
   * Set relationships between actors
   */
  setRelationships(relationships: ActorRelationship[]) {
    this.relationships = relationships;
  }
  /**
   * Generate a day's worth of feed activity from world events
   * 
   * Information flow (like real social media):
   * 1. Event happens (players never see it directly)
   * 2. Journalists/insiders break the story
   * 3. Involved parties react (defensive if bad, celebratory if good)
   * 4. Experts and commentators weigh in
   * 5. Conspiracy theorists create wild narratives
   * 6. Regular folks react and create threads
   * 
   * ALL posts generated by LLM with actor personality
   */
  async generateDayFeed(
    day: number,
    worldEvents: WorldEvent[],
    allActors: Actor[],
    outcome: boolean
  ): Promise<FeedPost[]> {
    const feed: FeedPost[] = [];

    // For each world event, generate cascading reactions
    for (let eventIndex = 0; eventIndex < worldEvents.length; eventIndex++) {
      const worldEvent = worldEvents[eventIndex];
      if (!worldEvent) continue; // Skip if event doesn't exist
      const eventFeed = await this.generateEventCascade(day, worldEvent, allActors, outcome, eventIndex);
      feed.push(...eventFeed);
    }

    // Add some standalone commentary unrelated to specific events
    const ambientNoise = await this.generateAmbientFeed(day, allActors, outcome);
    feed.push(...ambientNoise);

    // Generate replies (30-50% of existing posts get replies)
    const replies = await this.generateReplies(day, feed, allActors);
    feed.push(...replies);

    // Sort by timestamp for realistic feed flow
    return feed.sort((a, b) => a.timestamp.localeCompare(b.timestamp));
  }

  /**
   * Generate cascading feed posts for a single world event
   * Information cascade: News Break → Direct Reactions → Analysis → Conspiracy → Threads
   * OPTIMIZED: Uses batched LLM calls (10-15 calls → 4-5 calls per event)
   */
  private async generateEventCascade(
    day: number,
    worldEvent: WorldEvent,
    allActors: Actor[],
    outcome: boolean,
    eventIndex: number = 0
  ): Promise<FeedPost[]> {
    const cascade: FeedPost[] = [];
    const baseTime = `2025-10-${String(day).padStart(2, '0')}T`;
    // Offset hours based on event index so each event's posts are at different times
    const baseHourOffset = eventIndex * 4; // Events spaced 4 hours apart

    // 1. MEDIA ORGANIZATIONS BREAK THE STORY (if public event) - BATCHED
    if (worldEvent.visibility === 'public' || worldEvent.visibility === 'leaked') {
      const mediaOrgs = this.organizations.filter(o => o.type === 'media').slice(0, 2);
      const journalists = allActors.filter(a =>
        a.domain?.includes('media') || a.domain?.includes('journalism')
      ).slice(0, 2);

      let postIndex = 0;

      // ✅ BATCH: Media organizations
      if (mediaOrgs.length > 0) {
        const mediaPosts = await this.generateMediaPostsBatch(mediaOrgs, worldEvent, allActors, outcome, day);

        mediaPosts.forEach((post, i) => {
          const entity = mediaOrgs[i];
          if (!entity) return;

          cascade.push({
            id: `${worldEvent.id}-media-${i}`,
            day,
            timestamp: `${baseTime}${String((9 + baseHourOffset + postIndex * 2) % 24).padStart(2, '0')}:${String(Math.floor(Math.random() * 60)).padStart(2, '0')}:00Z`,
            type: 'news',
            content: post.post,
            author: entity.id,
            authorName: entity.name,
            relatedEvent: worldEvent.id,
            sentiment: post.sentiment,
            clueStrength: post.clueStrength,
            pointsToward: post.pointsToward,
          });
          postIndex++;
        });
      }

      // ✅ BATCH: Journalists (separate, more specific prompt)
      if (journalists.length > 0) {
        const journalistPosts = await this.generateJournalistPostsBatch(journalists, worldEvent, outcome, day);

        journalistPosts.forEach((post, i) => {
          const journalist = journalists[i];
          if (!journalist) return;

          cascade.push({
            id: `${worldEvent.id}-journalist-${i}`,
            day,
            timestamp: `${baseTime}${String((9 + baseHourOffset + postIndex * 2) % 24).padStart(2, '0')}:${String(Math.floor(Math.random() * 60)).padStart(2, '0')}:00Z`,
            type: 'news',
            content: post.post,
            author: journalist.id,
            authorName: journalist.name,
            relatedEvent: worldEvent.id,
            sentiment: post.sentiment,
            clueStrength: post.clueStrength,
            pointsToward: post.pointsToward,
          });
          postIndex++;
        });
      }
    }

    // 2. INVOLVED PARTIES REACT - BATCHED
    const involvedActors = worldEvent.actors
      .map(id => allActors.find(a => a.id === id))
      .filter((a): a is Actor => a !== undefined);

    if (involvedActors.length > 0) {
      // ✅ BATCH: All reactions in ONE call - can now see previous media posts
      const reactions = await this.generateReactionsBatch(involvedActors, worldEvent, outcome, cascade, day);
      
      // Collect companies that need to respond
      const companiesToRespond: Array<{ company: Organization; actor: Actor; index: number }> = [];
      
      reactions.forEach((reaction, i) => {
        const actor = involvedActors[i];
        if (!actor) return; // Skip if actor doesn't exist

        cascade.push({
          id: `${worldEvent.id}-reaction-${actor.id}`,
          day,
          timestamp: `${baseTime}${String((12 + baseHourOffset + i * 3) % 24).padStart(2, '0')}:${String(Math.floor(Math.random() * 60)).padStart(2, '0')}:00Z`,
          type: 'reaction',
          content: reaction.post,
          author: actor.id,
          authorName: actor.name,
          relatedEvent: worldEvent.id,
          sentiment: reaction.sentiment,
          clueStrength: reaction.clueStrength,
          pointsToward: reaction.pointsToward,
        });

        // Collect company affiliations for batch processing
        if (actor.affiliations) {
          const affiliatedCompanies = this.organizations.filter(o =>
            o.type === 'company' && actor.affiliations?.includes(o.id)
          ).slice(0, 1); // Usually just one company responds per actor

          affiliatedCompanies.forEach(company => {
            companiesToRespond.push({ company, actor, index: i });
          });
        }
      });
      
      // ✅ BATCH: All company responses in ONE call - can see reactions
      if (companiesToRespond.length > 0) {
        const companyPosts = await this.generateCompanyPostsBatch(
          companiesToRespond.map(({ company, actor }) => ({ company, actor })),
          worldEvent,
          outcome,
          cascade,
          day
        );

        companyPosts.forEach((post, i) => {
          const { company } = companiesToRespond[i]!;

          cascade.push({
            id: `${worldEvent.id}-company-${company.id}`,
            day,
            timestamp: `${baseTime}${String((13 + baseHourOffset + i * 3) % 24).padStart(2, '0')}:${String(Math.floor(Math.random() * 60)).padStart(2, '0')}:00Z`,
            type: 'reaction',
            content: post.post,
            author: company.id,
            authorName: company.name,
            relatedEvent: worldEvent.id,
            sentiment: post.sentiment,
            clueStrength: post.clueStrength,
            pointsToward: post.pointsToward,
          });
        });
      }
    }
    
    // 2b. GOVERNMENT RESPONSES (if applicable) - BATCHED
    if (worldEvent.type === 'scandal' || worldEvent.type === 'revelation') {
      const govOrgs = this.organizations.filter(o => o.type === 'government').slice(0, 1);

      if (govOrgs.length > 0) {
        // ✅ BATCH: All government responses in ONE call - can see reactions and companies
        const govPosts = await this.generateGovernmentPostsBatch(govOrgs, worldEvent, outcome, cascade, day);

        govPosts.forEach((post, i) => {
          const gov = govOrgs[i];
          if (!gov) return;

          cascade.push({
            id: `${worldEvent.id}-govt-${gov.id}`,
            day,
            timestamp: `${baseTime}${String((15 + baseHourOffset + i) % 24).padStart(2, '0')}:${String(Math.floor(Math.random() * 60)).padStart(2, '0')}:00Z`,
            type: 'reaction',
            content: post.post,
            author: gov.id,
            authorName: gov.name,
            relatedEvent: worldEvent.id,
            sentiment: post.sentiment,
            clueStrength: post.clueStrength,
            pointsToward: post.pointsToward,
          });
        });
      }
    }

    // 3. EXPERTS AND COMMENTATORS - BATCHED
    const commentators = allActors.filter(a => 
      !worldEvent.actors.includes(a.id) && // Not directly involved
      (a.domain?.includes('tech') || a.domain?.includes('policy') || a.role === 'supporting')
    ).slice(0, 2);
    
    if (commentators.length > 0) {
      // ✅ BATCH: All commentary in ONE call - can see everything so far
      const commentary = await this.generateCommentaryBatch(commentators, worldEvent, outcome, cascade, day);
      
      commentary.forEach((post, i) => {
        const commentator = commentators[i];
        if (!commentator) return; // Skip if commentator doesn't exist

        cascade.push({
          id: `${worldEvent.id}-expert-${i}`,
          day,
          timestamp: `${baseTime}${String((14 + baseHourOffset + i * 2) % 24).padStart(2, '0')}:${String(Math.floor(Math.random() * 60)).padStart(2, '0')}:00Z`,
          type: 'reaction',
          content: post.post,
          author: commentator.id,
          authorName: commentator.name,
          relatedEvent: worldEvent.id,
          sentiment: post.sentiment,
          clueStrength: post.clueStrength,
          pointsToward: post.pointsToward,
        });
      });
    }

    // 4. CONSPIRACISTS AND CONTRARIANS - BATCHED
    const conspiracists = allActors.filter(a => 
      a.personality?.includes('contrarian') || a.personality?.includes('paranoid') || 
      a.description?.toLowerCase().includes('conspiracy')
    ).slice(0, 1 + Math.floor(Math.random() * 2)); // 1-2 conspiracy posts

    if (conspiracists.length > 0) {
      // ✅ BATCH: All conspiracy posts in ONE call - can twist everything above
      const conspiracyPosts = await this.generateConspiracyPostsBatch(conspiracists, worldEvent, outcome, cascade, day);
      
      conspiracyPosts.forEach((post, i) => {
        const actor = conspiracists[i % conspiracists.length];
        if (actor) {
          cascade.push({
            id: `${worldEvent.id}-conspiracy-${i}`,
            day,
            timestamp: `${baseTime}${String((16 + baseHourOffset + i * 3) % 24).padStart(2, '0')}:${String(Math.floor(Math.random() * 60)).padStart(2, '0')}:00Z`,
            type: 'reaction',
            content: post.post,
            author: actor.id,
            authorName: actor.name,
            relatedEvent: worldEvent.id,
            sentiment: post.sentiment,
            clueStrength: post.clueStrength,
            pointsToward: post.pointsToward,
          });
        }
      });
    }

    // 5. THREAD DEVELOPMENT - BATCHED
    if (cascade.length >= 2) {
      const thread = await this.generateThread(day, cascade, allActors);
      cascade.push(...thread);
    }

    return cascade;
  }

  /**
   * BATCHED: Generate media posts for multiple organizations/journalists in ONE call
   * Reduces N calls → 1 call
   */
  private async generateMediaPostsBatch(
    mediaEntities: (Organization | Actor)[],
    worldEvent: WorldEvent,
    allActors: Actor[],
    outcome: boolean,
    day: number
  ): Promise<Array<{ post: string; sentiment: number; clueStrength: number; pointsToward: boolean | null }>> {
    if (!this.llm || mediaEntities.length === 0) {
      return [];
    }

    const potentialSource = allActors.find(a => worldEvent.actors.includes(a.id));

    // Build context using helper functions
    const phaseContext = buildPhaseContext(day);
    const orgBehaviorContext = buildOrganizationBehaviorContext(
      this.organizations.filter(o => o.type === 'media')
    );

    // Format variables for prompt template
    const sourceContext = potentialSource
      ? `Sources close to ${potentialSource.name} leaked information.`
      : '';

    const outcomeFrame = outcome
      ? 'Frame with positive spin'
      : 'Emphasize problems and concerns';

    const mediaList = mediaEntities.map((entity, i) => {
      const isOrg = 'type' in entity && entity.type === 'media';
      const voiceContext = formatActorVoiceContext(entity);
      let emotionalContext = '';
      if (!isOrg && 'id' in entity) {
        const state = this.actorStates.get(entity.id);
        emotionalContext = state
          ? '\n   ' + generateActorContext(state.mood, state.luck, undefined, this.relationships, entity.id).replace(/\n/g, '\n   ')
          : '';
      }
      return `${i + 1}. ${entity.name}
   About: ${entity.description}
   ${isOrg ? 'Style: Media organization - use "Breaking:", "Exclusive:", "Sources say:"' : 'Style: Journalist - more objective reporting'}${voiceContext}${emotionalContext}
   Max 280 chars, provocative and attention-grabbing. Match their writing style.
   NO hashtags or emojis.`;
    }).join('\n');

    const prompt = loadPrompt('feed/news-posts', {
      eventDescription: worldEvent.description,
      eventType: worldEvent.type,
      sourceContext,
      outcomeFrame,
      mediaCount: mediaEntities.length,
      mediaList,
      phaseContext,
      orgBehaviorContext
    });

    const maxRetries = 5;
    for (let attempt = 0; attempt < maxRetries; attempt++) {
      const response = await this.llm.generateJSON<{ posts: Array<{ post?: string; tweet?: string; sentiment: number; clueStrength: number; pointsToward: boolean | null }> }>(
        prompt,
        undefined, // Don't validate schema to handle various response formats
        { temperature: 0.9, maxTokens: 5000 }
      );

      const posts = Array.isArray(response.posts) ? response.posts : [];
      const validPosts = posts
        .filter(p => {
          const content = p.post || p.tweet;
          return content && typeof content === 'string' && content.trim().length > 0;
        })
        .map(p => ({
          post: p.post || p.tweet!,
          sentiment: p.sentiment,
          clueStrength: p.clueStrength,
          pointsToward: p.pointsToward,
        }));
      const minRequired = Math.ceil(mediaEntities.length * 0.5);
      
      if (validPosts.length >= minRequired) {
        // Limit to requested count to match with entities
        return validPosts.slice(0, mediaEntities.length);
      }

      console.warn(`⚠️  Invalid media batch (attempt ${attempt + 1}/${maxRetries}). Expected ${mediaEntities.length}, got ${validPosts.length} valid (need ${minRequired}+)`);
      if (attempt < maxRetries - 1) {
        await new Promise(resolve => setTimeout(resolve, 1000));
      }
    }

    throw new Error(`Failed to generate media posts batch after ${maxRetries} attempts`);
  }

  /**
   * BATCHED: Generate journalist posts for multiple journalists in ONE call
   * Reduces N calls → 1 call
   */
  private async generateJournalistPostsBatch(
    journalists: Actor[],
    worldEvent: WorldEvent,
    outcome: boolean,
    day: number
  ): Promise<Array<{ post: string; sentiment: number; clueStrength: number; pointsToward: boolean | null }>> {
    if (!this.llm || journalists.length === 0) {
      return [];
    }

    // Build context using helper functions
    const phaseContext = buildPhaseContext(day);
    const relationshipContext = buildRelationshipContext(journalists, this.relationships);

    const outcomeFrame = outcome
      ? 'Frame with slightly positive spin'
      : 'Emphasize concerns and challenges';

    const journalistsList = journalists.map((journalist, i) => {
      const state = this.actorStates.get(journalist.id);
      const emotionalContext = state
        ? '\n   ' + generateActorContext(state.mood, state.luck, undefined, this.relationships, journalist.id).replace(/\n/g, '\n   ')
        : '';
      const voiceContext = formatActorVoiceContext(journalist);

      return loadPrompt('feed/journalist-instruction', {
        index: (i + 1).toString(),
        journalistName: journalist.name,
        journalistDescription: journalist.description,
        affiliations: journalist.affiliations?.join(', ') || 'independent',
        emotionalContext,
        voiceContext
      });
    }).join('\n');

    const prompt = loadPrompt('feed/journalist-posts', {
      eventDescription: worldEvent.description,
      eventType: worldEvent.type,
      outcomeFrame,
      journalistCount: journalists.length,
      journalistsList,
      phaseContext,
      relationshipContext
    });

    const maxRetries = 5;
    for (let attempt = 0; attempt < maxRetries; attempt++) {
      const response = await this.llm.generateJSON<{ posts: Array<{ post?: string; tweet?: string; sentiment: number; clueStrength: number; pointsToward: boolean | null }> }>(
        prompt,
        undefined,
        { temperature: 0.9, maxTokens: 5000 }
      );

      const posts = Array.isArray(response.posts) ? response.posts : [];
      const validPosts = posts
        .filter(p => {
          const content = p.post || p.tweet;
          return content && typeof content === 'string' && content.trim().length > 0;
        })
        .map(p => ({
          post: p.post || p.tweet!,
          sentiment: p.sentiment,
          clueStrength: p.clueStrength,
          pointsToward: p.pointsToward,
        }));
      const minRequired = Math.ceil(journalists.length * 0.5);

      if (validPosts.length >= minRequired) {
        return validPosts.slice(0, journalists.length);
      }

      console.warn(`⚠️  Invalid journalist batch (attempt ${attempt + 1}/${maxRetries}). Expected ${journalists.length}, got ${validPosts.length} valid (need ${minRequired}+)`);
      if (attempt < maxRetries - 1) {
        await new Promise(resolve => setTimeout(resolve, 1000));
      }
    }

    throw new Error(`Failed to generate journalist posts batch after ${maxRetries} attempts`);
  }

  /**
   * BATCHED: Generate company posts for multiple companies in ONE call
   * Reduces N calls → 1 call
   */
  private async generateCompanyPostsBatch(
    companies: Array<{ company: Organization; actor: Actor }>,
    worldEvent: WorldEvent,
    outcome: boolean,
    previousPosts: FeedPost[] = [],
    day: number
  ): Promise<Array<{ post: string; sentiment: number; clueStrength: number; pointsToward: boolean | null }>> {
    if (!this.llm || companies.length === 0) {
      return [];
    }

    // Build context using helper functions
    const phaseContext = buildPhaseContext(day);
    const orgBehaviorContext = buildOrganizationBehaviorContext(
      companies.map(c => c.company)
    );

    const outcomeFrame = outcome
      ? 'Frame positively - opportunity, innovation, growth'
      : 'Defensive - managing concerns, staying course';

    // Build context from previous posts in cascade - corporate responses should see public sentiment
    const previousPostsContext = previousPosts.length > 0
      ? `\nPrevious posts about this event:\n${previousPosts.slice(-5).map(p => `- @${p.authorName}: "${p.content}"`).join('\n')}`
      : '';

    const companiesList = companies.map(({ company, actor }, i) => {
      const postType = worldEvent.actors.includes(actor.id) ? 'response' : 'statement';

      return loadPrompt('feed/company-instruction', {
        index: (i + 1).toString(),
        companyName: company.name,
        companyDescription: company.description,
        companyType: company.type || 'company',
        postType
      });
    }).join('\n');

    const prompt = loadPrompt('feed/company-posts', {
      eventDescription: worldEvent.description,
      eventType: worldEvent.type,
      outcomeFrame,
      previousPostsContext,
      companyCount: companies.length,
      companiesList,
      phaseContext,
      orgBehaviorContext
    });

    const maxRetries = 5;
    for (let attempt = 0; attempt < maxRetries; attempt++) {
      const response = await this.llm.generateJSON<{ posts: Array<{ post?: string; tweet?: string; sentiment: number; clueStrength: number; pointsToward: boolean | null }> }>(
        prompt,
        undefined,
        { temperature: 0.8, maxTokens: 5000 }
      );

      const posts = Array.isArray(response.posts) ? response.posts : [];
      const validPosts = posts
        .filter(p => {
          const content = p.post || p.tweet;
          return content && typeof content === 'string' && content.trim().length > 0;
        })
        .map(p => ({
          post: p.post || p.tweet!,
          sentiment: p.sentiment,
          clueStrength: p.clueStrength,
          pointsToward: p.pointsToward,
        }));
      const minRequired = Math.ceil(companies.length * 0.5);

      if (validPosts.length >= minRequired) {
        return validPosts.slice(0, companies.length);
      }

      console.warn(`⚠️  Invalid company batch (attempt ${attempt + 1}/${maxRetries}). Expected ${companies.length}, got ${validPosts.length} valid (need ${minRequired}+)`);
      if (attempt < maxRetries - 1) {
        await new Promise(resolve => setTimeout(resolve, 1000));
      }
    }

    throw new Error(`Failed to generate company posts batch after ${maxRetries} attempts`);
  }

  /**
   * BATCHED: Generate government posts for multiple agencies in ONE call
   * Reduces N calls → 1 call
   */
  private async generateGovernmentPostsBatch(
    governments: Organization[],
    worldEvent: WorldEvent,
    outcome: boolean,
    previousPosts: FeedPost[] = [],
    day: number
  ): Promise<Array<{ post: string; sentiment: number; clueStrength: number; pointsToward: boolean | null }>> {
    if (!this.llm || governments.length === 0) {
      return [];
    }

    // Build context using helper functions
    const phaseContext = buildPhaseContext(day);
    const orgBehaviorContext = buildOrganizationBehaviorContext(governments);

    const outcomeFrame = outcome
      ? 'Cautiously supportive - monitoring with optimism'
      : 'Concerned - emphasize oversight and caution';

    // Build context from previous posts in cascade - government statements should reference public discourse
    const previousPostsContext = previousPosts.length > 0
      ? `\nPrevious posts about this event:\n${previousPosts.slice(-5).map(p => `- @${p.authorName}: "${p.content}"`).join('\n')}`
      : '';

    const governmentsList = governments.map((gov, i) => {
      return loadPrompt('feed/government-instruction', {
        index: (i + 1).toString(),
        governmentName: gov.name,
        governmentDescription: gov.description,
        governmentType: gov.type || 'government'
      });
    }).join('\n');

    const prompt = loadPrompt('feed/government-posts', {
      eventDescription: worldEvent.description,
      eventType: worldEvent.type,
      outcomeFrame,
      previousPostsContext,
      governmentCount: governments.length,
      governmentsList,
      phaseContext,
      orgBehaviorContext
    });

    const maxRetries = 5;
    for (let attempt = 0; attempt < maxRetries; attempt++) {
      const response = await this.llm.generateJSON<{ posts: Array<{ post?: string; tweet?: string; sentiment: number; clueStrength: number; pointsToward: boolean | null }> }>(
        prompt,
        undefined,
        { temperature: 0.7, maxTokens: 5000 }
      );

      const posts = Array.isArray(response.posts) ? response.posts : [];
      const validPosts = posts
        .filter(p => {
          const content = p.post || p.tweet;
          return content && typeof content === 'string' && content.trim().length > 0;
        })
        .map(p => ({
          post: p.post || p.tweet!,
          sentiment: p.sentiment,
          clueStrength: p.clueStrength,
          pointsToward: p.pointsToward,
        }));
      const minRequired = Math.ceil(governments.length * 0.5);

      if (validPosts.length >= minRequired) {
        return validPosts.slice(0, governments.length);
      }

      console.warn(`⚠️  Invalid government batch (attempt ${attempt + 1}/${maxRetries}). Expected ${governments.length}, got ${validPosts.length} valid (need ${minRequired}+)`);
      if (attempt < maxRetries - 1) {
        await new Promise(resolve => setTimeout(resolve, 1000));
      }
    }

    throw new Error(`Failed to generate government posts batch after ${maxRetries} attempts`);
  }

  /**
   * BATCHED: Generate reactions for multiple actors in ONE call
   * Preserves per-actor context (mood, luck, personality)
   * Uses worldEvent.pointsToward when available, outcome for narrative coherence otherwise
   */
  private async generateReactionsBatch(
    actors: Actor[],
    worldEvent: WorldEvent,
    outcome: boolean,
    previousPosts: FeedPost[] = [],
    day: number
  ): Promise<Array<{ post: string; sentiment: number; clueStrength: number; pointsToward: boolean | null }>> {
    if (!this.llm || actors.length === 0) {
      return [];
    }

    // Build context using helper functions
    const phaseContext = buildPhaseContext(day);
    const relationshipContext = buildRelationshipContext(actors, this.relationships);

    const actorContexts = actors.map(actor => {
      const state = this.actorStates.get(actor.id);
      const emotionalContext = state
        ? generateActorContext(state.mood, state.luck, undefined, this.relationships, actor.id)
        : '';

      return {
        actor,
        emotionalContext,
      };
    });

    // Use event's explicit hint if available, otherwise use outcome for coherence
    // This ensures: explicit hints are respected, ambiguous events maintain narrative consistency
    const eventContext = worldEvent.pointsToward
      ? `This development suggests things are trending toward ${worldEvent.pointsToward}.`
      : `Based on this event, the situation is ${outcome ? 'progressing positively' : 'facing setbacks'}.`;

    // Build context from previous posts in cascade
    const previousPostsContext = previousPosts.length > 0
      ? `\nPrevious posts about this event:\n${previousPosts.slice(-5).map(p => `- @${p.authorName}: "${p.content}"`).join('\n')}`
      : '';

    const actorsList = actorContexts.map((ctx, i) =>
      loadPrompt('feed/reaction-instruction', {
        index: (i + 1).toString(),
        actorName: ctx.actor.name,
        actorDescription: ctx.actor.description,
        affiliations: ctx.actor.affiliations?.join(', ') || 'independent',
        emotionalContext: ctx.emotionalContext,
        voiceContext: formatActorVoiceContext(ctx.actor),
        groupContext: this.actorGroupContexts.get(ctx.actor.id) || ''
      })
    ).join('\n');

    const prompt = loadPrompt('feed/reactions', {
      eventDescription: worldEvent.description,
      eventContext,
      previousPostsContext,
      actorCount: actors.length,
      actorsList,
      phaseContext,
      relationshipContext
    });

    const maxRetries = 5;
    for (let attempt = 0; attempt < maxRetries; attempt++) {
      const response = await this.llm.generateJSON<{ reactions: Array<{ post?: string; tweet?: string; sentiment: number; clueStrength: number; pointsToward: boolean | null }> }>(
        prompt,
        undefined, // Don't validate schema to handle various response formats
        { temperature: 1.0, maxTokens: 5000 }
      );

      const reactions = Array.isArray(response.reactions) ? response.reactions : [];
      const validReactions = reactions
        .filter(r => {
          const content = r.post || r.tweet;
          return content && typeof content === 'string' && content.trim().length > 0;
        })
        .map(r => ({
          post: r.post || r.tweet!,
          sentiment: r.sentiment,
          clueStrength: r.clueStrength,
          pointsToward: r.pointsToward,
        }));
      const minRequired = Math.ceil(actors.length * 0.5);
      
      if (validReactions.length >= minRequired) {
        // Limit to requested count to match with actors
        return validReactions.slice(0, actors.length);
      }

      console.warn(`⚠️  Invalid reactions batch (attempt ${attempt + 1}/${maxRetries}). Expected ${actors.length}, got ${validReactions.length} valid (need ${minRequired}+)`);
      if (attempt < maxRetries - 1) {
        await new Promise(resolve => setTimeout(resolve, 1000));
      }
    }

    throw new Error(`Failed to generate reactions batch after ${maxRetries} attempts`);
  }

  /**
   * BATCHED: Generate commentary for multiple experts in ONE call
   */
  private async generateCommentaryBatch(
    commentators: Actor[],
    worldEvent: WorldEvent,
    outcome: boolean,
    previousPosts: FeedPost[] = [],
    day: number
  ): Promise<Array<{ post: string; sentiment: number; clueStrength: number; pointsToward: boolean | null }>> {
    if (!this.llm || commentators.length === 0) {
      return [];
    }

    // Build context using helper functions
    const phaseContext = buildPhaseContext(day);
    const relationshipContext = buildRelationshipContext(commentators, this.relationships);

    const contexts = commentators.map(actor => {
      const state = this.actorStates.get(actor.id);
      const emotionalContext = state
        ? generateActorContext(state.mood, state.luck, undefined, this.relationships, actor.id)
        : '';

      return { actor, emotionalContext };
    });

    // Build context from previous posts in cascade
    const previousPostsContext = previousPosts.length > 0
      ? `\nPrevious posts about this event:\n${previousPosts.slice(-5).map(p => `- @${p.authorName}: "${p.content}"`).join('\n')}`
      : '';

    const commentatorsList = contexts.map((ctx, i) => `${i + 1}. ${ctx.actor.name}
   About: ${ctx.actor.description}
   Domain: ${ctx.actor.domain?.join(', ')}
   ${ctx.emotionalContext}${formatActorVoiceContext(ctx.actor)}

   Write analysis as outside observer (max 280 chars).
   ${outcome ? 'Lean optimistic' : 'Lean skeptical'}
   Let mood subtly influence tone. Match their writing style.
   NO hashtags or emojis.`).join('\n');

    const prompt = loadPrompt('feed/commentary', {
      eventDescription: worldEvent.description,
      previousPostsContext,
      commentatorCount: commentators.length,
      commentatorsList,
      phaseContext,
      relationshipContext
    });

    const maxRetries = 5;
    for (let attempt = 0; attempt < maxRetries; attempt++) {
      const response = await this.llm.generateJSON<{ commentary: Array<{ post?: string; tweet?: string; sentiment: number; clueStrength: number; pointsToward: boolean | null }> }>(
        prompt,
        undefined, // Don't validate schema to handle various response formats
        { temperature: 1.0, maxTokens: 5000 }
      );

      const commentary = Array.isArray(response.commentary) ? response.commentary : [];
      const validCommentary = commentary
        .filter(c => {
          const content = c.post || c.tweet;
          return content && typeof content === 'string' && content.trim().length > 0;
        })
        .map((c: any) => ({
          post: c.post || c.tweet!,
          sentiment: c.sentiment || 0,
          clueStrength: c.clueStrength || 0,
          pointsToward: c.pointsToward || null,
        }));
      const minRequired = Math.ceil(commentators.length * 0.5);
      
      if (validCommentary.length >= minRequired) {
        // Limit to requested count to match with commentators
        return validCommentary.slice(0, commentators.length);
      }

      console.warn(`⚠️  Invalid commentary batch (attempt ${attempt + 1}/${maxRetries}). Expected ${commentators.length}, got ${validCommentary.length} valid (need ${minRequired}+)`);
      if (attempt < maxRetries - 1) {
        await new Promise(resolve => setTimeout(resolve, 1000));
      }
    }

    throw new Error(`Failed to generate commentary batch after ${maxRetries} attempts`);
  }

  /**
   * BATCHED: Generate conspiracy posts for multiple actors in ONE call
   */
  private async generateConspiracyPostsBatch(
    conspiracists: Actor[],
    worldEvent: WorldEvent,
    outcome: boolean,
    previousPosts: FeedPost[] = [],
    day: number
  ): Promise<Array<{ post: string; sentiment: number; clueStrength: number; pointsToward: boolean | null }>> {
    if (!this.llm || conspiracists.length === 0) {
      return [];
    }

    // Build context using helper functions
    const phaseContext = buildPhaseContext(day);
    const relationshipContext = buildRelationshipContext(conspiracists, this.relationships);

    // Build context from previous posts in cascade - conspiracy theories twist the existing narrative
    const previousPostsContext = previousPosts.length > 0
      ? `\nPrevious posts about this event:\n${previousPosts.slice(-5).map(p => `- @${p.authorName}: "${p.content}"`).join('\n')}`
      : '';

    const conspiracistsList = conspiracists.map((actor, i) => `${i + 1}. ${actor.name}
   About: ${actor.description}${formatActorVoiceContext(actor)}

   You don't believe the mainstream narrative.
   Write conspiracy post (max 280 chars).
   Be dramatic, suspicious. Match their writing style.
   NO hashtags or emojis.
   ${outcome ? "Claim it's a distraction" : "Say they're hiding worse"}`).join('\n');

    const prompt = loadPrompt('feed/conspiracy', {
      eventDescription: worldEvent.description,
      previousPostsContext,
      conspiracistCount: conspiracists.length,
      conspiracistsList,
      phaseContext,
      relationshipContext
    });

    const maxRetries = 5;
    for (let attempt = 0; attempt < maxRetries; attempt++) {
      const rawResponse = await this.llm.generateJSON<{ conspiracy: Array<{ post?: string; tweet?: string; sentiment: number; clueStrength: number; pointsToward: boolean | null }> } | { data: Array<{ conspiracy: Array<any> }> }>(
        prompt,
        undefined, // Don't validate schema, we'll handle both formats
        { temperature: 1.1, maxTokens: 5000 }
      );

      // Handle both response formats
      let conspiracy: ConspiracyPost[] = [];
      if ('conspiracy' in rawResponse && Array.isArray(rawResponse.conspiracy)) {
        conspiracy = rawResponse.conspiracy as ConspiracyPost[];
      } else if ('data' in rawResponse && Array.isArray(rawResponse.data) && rawResponse.data[0]?.conspiracy) {
        // Unwrap from { data: [{ conspiracy: [...] }] }
        conspiracy = rawResponse.data.flatMap((d: Record<string, unknown>) => (d.conspiracy as ConspiracyPost[]) || []);
      }

      const validConspiracy = conspiracy
        .filter(c => {
          const content = c.post || c.tweet;
          return content && typeof content === 'string' && content.trim().length > 0;
        })
        .map((c: any) => ({
          post: c.post || c.tweet!,
          sentiment: c.sentiment || 0,
          clueStrength: c.clueStrength || 0,
          pointsToward: c.pointsToward || null,
        }));
      const minRequired = Math.ceil(conspiracists.length * 0.5);
      
      if (validConspiracy.length >= minRequired) {
        // Limit to requested count to match with conspiracists
        return validConspiracy.slice(0, conspiracists.length);
      }

      console.warn(`⚠️  Invalid conspiracy batch (attempt ${attempt + 1}/${maxRetries}). Expected ${conspiracists.length}, got ${validConspiracy.length} valid (need ${minRequired}+)`);
      if (attempt < maxRetries - 1) {
        await new Promise(resolve => setTimeout(resolve, 1000));
      }
    }

    throw new Error(`Failed to generate conspiracy posts batch after ${maxRetries} attempts`);
  }

  /**
   * Generate journalist breaking news post
   * Journalists report events objectively (with slight bias)
   * Public for external use and testing
   */
  public async generateJournalistPost(
    journalist: Actor,
    event: WorldEvent,
    outcome: boolean
  ): Promise<{ post: string; sentiment: number; clueStrength: number; pointsToward: boolean | null }> {
    if (!this.llm) {
      throw new Error('LLM client required for feed generation');
    }

    const state = this.actorStates.get(journalist.id);
    const emotionalContext = state
      ? generateActorContext(state.mood, state.luck, undefined, this.relationships, journalist.id)
      : '';

    const outcomeFrame = outcome ? 'Frame as potentially positive' : 'Highlight concerns or problems';

    const prompt = loadPrompt('feed/journalist-post', {
      journalistName: journalist.name,
      journalistDescription: journalist.description,
      emotionalContext: emotionalContext ? emotionalContext + '\n' : '',
      eventDescription: event.description,
      eventType: event.type,
      outcomeFrame
    });

    // Retry until we get non-empty content
    const maxRetries = 5;
    for (let attempt = 0; attempt < maxRetries; attempt++) {
      const response = await this.llm.generateJSON<{ 
        post: string;
        sentiment: number;
        clueStrength: number;
        pointsToward: boolean | null;
      }>(
        prompt,
        { required: ['post', 'sentiment', 'clueStrength', 'pointsToward'] },
        { temperature: 0.9, maxTokens: 5000 }
      );

      if (response.post && typeof response.post === 'string' && response.post.trim().length > 0) {
        return response;
      }

      console.error('Invalid response from LLM:', JSON.stringify(response, null, 2));
      console.warn(`⚠️  Invalid journalist post (attempt ${attempt + 1}/${maxRetries}). Retrying...`);
      if (attempt < maxRetries - 1) {
        await new Promise(resolve => setTimeout(resolve, 1000));
      }
    }

    throw new Error(`Failed to generate valid journalist post after ${maxRetries} attempts for ${journalist.name}`);
  }

  /**
   * Generate media organization post
   * Media breaks stories with bias, often citing anonymous sources
   * Public for external use and testing
   */
  public async generateMediaPost(
    media: Organization,
    event: WorldEvent,
    allActors: Actor[],
    outcome: boolean
  ): Promise<{ post: string; sentiment: number; clueStrength: number; pointsToward: boolean | null }> {
    if (!this.llm) {
      throw new Error('LLM client required for feed generation');
    }

    // Determine which actor might have "leaked" this to the media
    const potentialSource = allActors.find(a => event.actors.includes(a.id));

    const sourceHint = potentialSource
      ? `Hint: You received information from sources close to ${potentialSource.name} (but DON'T reveal the source directly).`
      : 'You have your own sources.';

    const outcomeFrame = outcome
      ? 'Spin this with your typical editorial slant toward positive framing'
      : 'Spin this with your typical editorial slant emphasizing problems';

    const prompt = loadPrompt('feed/media-post', {
      mediaName: media.name,
      mediaDescription: media.description,
      eventDescription: event.description,
      eventType: event.type,
      sourceHint,
      outcomeFrame
    });

    const maxRetries = 5;
    for (let attempt = 0; attempt < maxRetries; attempt++) {
      const response = await this.llm.generateJSON<{ 
        post: string;
        sentiment: number;
        clueStrength: number;
        pointsToward: boolean | null;
      }>(
        prompt,
        { required: ['post', 'sentiment', 'clueStrength', 'pointsToward'] },
        { temperature: 0.9, maxTokens: 5000 }
      );

      if (response.post && typeof response.post === 'string' && response.post.trim().length > 0) {
        return response;
      }

      console.warn(`⚠️  Invalid media post (attempt ${attempt + 1}/${maxRetries}). Retrying...`);
      if (attempt < maxRetries - 1) {
        await new Promise(resolve => setTimeout(resolve, 1000));
      }
    }

    throw new Error(`Failed to generate valid media post after ${maxRetries} attempts for ${media.name}`);
  }

  /**
   * Generate company PR statement
   * Companies manage crises, spin news, and announce products
   * NOTE: Preserved for reference - use generateCompanyPostsBatch for production
   */
  // @ts-expect-error - Preserved for reference, use batch version in production
  private async _generateCompanyPost(
    company: Organization,
    event: WorldEvent,
    _affiliatedActor: Actor,
    outcome: boolean
  ): Promise<{ post: string; sentiment: number; clueStrength: number; pointsToward: boolean | null }> {
    if (!this.llm) {
      throw new Error('LLM client required for feed generation');
    }

    const isCrisis = event.type === 'scandal' || event.type === 'leak';
    const postType = isCrisis ? 'crisis management' : 'announcement';

    const outcomeFrame = outcome
      ? 'Frame as ultimately positive for the company'
      : 'Manage the negative optics professionally';

    const prompt = loadPrompt('feed/company-post', {
      companyName: company.name,
      companyDescription: company.description,
      eventDescription: event.description,
      eventType: event.type,
      postType,
      outcomeFrame
    });

    const maxRetries = 5;
    for (let attempt = 0; attempt < maxRetries; attempt++) {
      const response = await this.llm.generateJSON<{
        post: string;
        sentiment: number;
        clueStrength: number;
        pointsToward: boolean | null;
      }>(
        prompt,
        { required: ['post', 'sentiment', 'clueStrength', 'pointsToward'] },
        { temperature: 0.9, maxTokens: 5000 }
      );

      if (response.post && typeof response.post === 'string' && response.post.trim().length > 0) {
        return response;
      }

      console.warn(`⚠️  Invalid company post (attempt ${attempt + 1}/${maxRetries}). Retrying...`);
      if (attempt < maxRetries - 1) {
        await new Promise(resolve => setTimeout(resolve, 1000));
      }
    }

    throw new Error(`Failed to generate valid company post after ${maxRetries} attempts for ${company.name}`);
  }

  /**
   * Generate government response
   * Government agencies investigate, deny, or announce policy
   * NOTE: Preserved for reference - use generateGovernmentPostsBatch for production
   */
  // @ts-expect-error - Preserved for reference, use batch version in production
  private async _generateGovernmentPost(
    govt: Organization,
    event: WorldEvent,
    _allActors: Actor[],
    outcome: boolean
  ): Promise<{ post: string; sentiment: number; clueStrength: number; pointsToward: boolean | null }> {
    if (!this.llm) {
      throw new Error('LLM client required for feed generation');
    }

    // Find key actors that government might reference (insiders, executives, experts)
    const keyActors = _allActors
      .filter(a => a.role === 'insider' || a.role === 'executive' || a.role === 'expert')
      .slice(0, 3)
      .map(a => a.name);

    // @ts-expect-error - Context computed but not yet integrated into prompt
    const _actorContext = keyActors.length > 0
      ? `Key individuals involved: ${keyActors.join(', ')}. You may reference them if relevant.`
      : '';

    const outcomeFrame = outcome
      ? 'Frame as having things under control'
      : 'Show typical government ineffectiveness';

    const prompt = loadPrompt('feed/government-post', {
      govName: govt.name,
      govDescription: govt.description,
      eventDescription: event.description,
      eventType: event.type,
      outcomeFrame
    });

    const maxRetries = 5;
    for (let attempt = 0; attempt < maxRetries; attempt++) {
      const response = await this.llm.generateJSON<{
        post: string;
        sentiment: number;
        clueStrength: number;
        pointsToward: boolean | null;
      }>(
        prompt,
        { required: ['post', 'sentiment', 'clueStrength', 'pointsToward'] },
        { temperature: 0.9, maxTokens: 5000 }
      );

      if (response.post && typeof response.post === 'string' && response.post.trim().length > 0) {
        return response;
      }

      console.warn(`⚠️  Invalid government post (attempt ${attempt + 1}/${maxRetries}). Retrying...`);
      if (attempt < maxRetries - 1) {
        await new Promise(resolve => setTimeout(resolve, 1000));
      }
    }

    throw new Error(`Failed to generate valid government post after ${maxRetries} attempts for ${govt.name}`);
  }

  /**
   * Generate direct reaction from involved party
   * Defensive if bad, celebratory if good, motivated by self-interest
   * Public for external use and testing
   * Uses event.pointsToward when available, outcome for narrative coherence otherwise
   */
  public async generateDirectReaction(
    actor: Actor,
    event: WorldEvent,
    outcome: boolean
  ): Promise<{ post: string; sentiment: number; clueStrength: number; pointsToward: boolean | null }> {
    if (!this.llm) {
      throw new Error('LLM client required for feed generation');
    }

    // Get actor's current emotional state
    const state = this.actorStates.get(actor.id);
    const emotionalContext = state
      ? generateActorContext(state.mood, state.luck, undefined, this.relationships, actor.id)
      : '';

    // Use event's explicit hint if available, otherwise use outcome for coherence
    const eventGuidance = event.pointsToward
      ? `This event suggests things are trending toward ${event.pointsToward}. React based on how this affects YOUR interests.`
      : `This situation is ${outcome ? 'developing in ways that could benefit some parties' : 'facing challenges that concern various stakeholders'}. React based on your role and interests.`;

    const outcomeFrame = outcome ? 'Frame positively if you can' : 'Defensive or damage control';

    const prompt = loadPrompt('feed/direct-reaction', {
      actorName: actor.name,
      actorDescription: actor.description,
      emotionalContext: emotionalContext ? `\n${emotionalContext}\n` : '',
      eventDescription: event.description,
      eventType: event.type,
      eventGuidance,
      outcomeFrame
    });

    const maxRetries = 5;
    for (let attempt = 0; attempt < maxRetries; attempt++) {
      const response = await this.llm.generateJSON<{ 
        post: string;
        sentiment: number;
        clueStrength: number;
        pointsToward: boolean | null;
      }>(
        prompt,
        { required: ['post', 'sentiment', 'clueStrength', 'pointsToward'] },
        { temperature: 1.0, maxTokens: 5000 }
      );

      if (response.post && typeof response.post === 'string' && response.post.trim().length > 0) {
        return response;
      }

      console.error('Invalid response from LLM:', JSON.stringify(response, null, 2));
      console.warn(`⚠️  Invalid reaction (attempt ${attempt + 1}/${maxRetries}). Retrying...`);
      if (attempt < maxRetries - 1) {
        await new Promise(resolve => setTimeout(resolve, 1000));
      }
    }

    throw new Error(`Failed to generate valid reaction after ${maxRetries} attempts for ${actor.name}`);
  }

  /**
   * Generate expert/commentator analysis
   * Outsiders analyzing what happened
   * Public for external use and testing
   */
  public async generateCommentary(
    actor: Actor,
    event: WorldEvent,
    outcome: boolean
  ): Promise<{ post: string; sentiment: number; clueStrength: number; pointsToward: boolean | null }> {
    if (!this.llm) {
      throw new Error('LLM client required for feed generation');
    }

    // Get actor's current emotional state
    const state = this.actorStates.get(actor.id);
    const emotionalContext = state
      ? generateActorContext(state.mood, state.luck, undefined, this.relationships, actor.id)
      : '';

    const outcomeFrame = outcome ? 'Lean optimistic' : 'Lean skeptical';

    const prompt = loadPrompt('feed/expert-commentary', {
      actorName: actor.name,
      actorDescription: actor.description,
      emotionalContext: emotionalContext ? `\n${emotionalContext}\n` : '',
      eventDescription: event.description,
      eventType: event.type,
      outcomeFrame
    });

    const maxRetries = 5;
    for (let attempt = 0; attempt < maxRetries; attempt++) {
      const response = await this.llm.generateJSON<{ 
        post: string;
        sentiment: number;
        clueStrength: number;
        pointsToward: boolean | null;
      }>(
        prompt,
        { required: ['post', 'sentiment', 'clueStrength', 'pointsToward'] },
        { temperature: 1.0, maxTokens: 5000 }
      );

      if (response.post && typeof response.post === 'string' && response.post.trim().length > 0) {
        return response;
      }

      console.error('Invalid response from LLM:', JSON.stringify(response, null, 2));
      console.warn(`⚠️  Invalid commentary (attempt ${attempt + 1}/${maxRetries}). Retrying...`);
      if (attempt < maxRetries - 1) {
        await new Promise(resolve => setTimeout(resolve, 1000));
      }
    }

    throw new Error(`Failed to generate valid commentary after ${maxRetries} attempts for ${actor.name}`);
  }

  /**
   * Generate conspiracy theory / wild spin
   * These actors create alternative narratives
   * Public for external use and testing
   */
  public async generateConspiracyPost(
    actor: Actor,
    event: WorldEvent,
    outcome: boolean
  ): Promise<{ post: string; sentiment: number; clueStrength: number; pointsToward: boolean | null }> {
    if (!this.llm) {
      throw new Error('LLM client required for feed generation');
    }

    const state = this.actorStates.get(actor.id);
    const emotionalContext = state
      ? generateActorContext(state.mood, state.luck, undefined, this.relationships, actor.id)
      : '';

    const outcomeFrame = outcome ? "Claim it's a distraction" : "Say they're hiding worse";

    const prompt = loadPrompt('feed/conspiracy-post', {
      actorName: actor.name,
      actorDescription: actor.description,
      emotionalContext: emotionalContext ? emotionalContext + '\n' : '',
      eventDescription: event.description,
      eventType: event.type,
      outcomeFrame
    });

    const maxRetries = 5;
    for (let attempt = 0; attempt < maxRetries; attempt++) {
      const response = await this.llm.generateJSON<{ 
        post: string;
        sentiment: number;
        clueStrength: number;
        pointsToward: boolean | null;
      }>(
        prompt,
        { required: ['post', 'sentiment', 'clueStrength', 'pointsToward'] },
        { temperature: 1.1, maxTokens: 5000 }
      );

      if (response.post && typeof response.post === 'string' && response.post.trim().length > 0) {
        return response;
      }

      console.error('Invalid response from LLM:', JSON.stringify(response, null, 2));
      console.warn(`⚠️  Invalid conspiracy post (attempt ${attempt + 1}/${maxRetries}). Retrying...`);
      if (attempt < maxRetries - 1) {
        await new Promise(resolve => setTimeout(resolve, 1000));
      }
    }

    throw new Error(`Failed to generate valid conspiracy post after ${maxRetries} attempts for ${actor.name}`);
  }

  /**
   * Generate ambient feed posts (not tied to specific events)
   * Random musings, hot takes, general commentary
   * BATCHED: Generates all ambient posts in ONE call
   */
  private async generateAmbientFeed(day: number, allActors: Actor[], outcome: boolean): Promise<FeedPost[]> {
    const ambient: FeedPost[] = [];
    const baseTime = `2025-10-${String(day).padStart(2, '0')}T`;

    // DENSE CONTENT: Each actor posts 1-20 times per hour
    // Generate posts for all 24 hours of the day
    
    // For each hour of the day, select random actors to post
    for (let hour = 0; hour < 24; hour++) {
      // Each hour, 10-30% of actors post (1-20 posts per actor per hour achieved through probability)
      const actorsThisHour = shuffleArray(allActors).slice(0, Math.floor(allActors.length * (0.1 + Math.random() * 0.2)));
      
      if (actorsThisHour.length === 0) continue;

      // ✅ BATCH: Generate all ambient posts for this hour in ONE call - can see earlier ambient posts
      const posts = await this.generateAmbientPostsBatch(actorsThisHour, day, outcome, ambient);
      
      posts.forEach((post, i) => {
        const actor = actorsThisHour[i];
        if (!actor) return;

        // Spread posts throughout the hour (random minutes)
        const minute = Math.floor(Math.random() * 60);
        const second = Math.floor(Math.random() * 60);

        ambient.push({
          id: `ambient-${day}-${hour}-${actor.id}-${i}`,
          day,
          timestamp: `${baseTime}${String(hour).padStart(2, '0')}:${String(minute).padStart(2, '0')}:${String(second).padStart(2, '0')}Z`,
          type: 'thread',
          content: post.post,
          author: actor.id,
          authorName: actor.name,
          sentiment: post.sentiment,
          clueStrength: post.clueStrength,
          pointsToward: post.pointsToward,
        });
      });
    }

    return ambient;
  }

  /**
   * Generate replies to existing posts
   * 30-50% of posts get replies from other actors
   */
  private async generateReplies(day: number, existingPosts: FeedPost[], allActors: Actor[]): Promise<FeedPost[]> {
    const replies: FeedPost[] = [];
    
    // Select posts that could get replies (30-50% of posts)
    const postsToReplyTo = shuffleArray(existingPosts).slice(0, Math.floor(existingPosts.length * (0.3 + Math.random() * 0.2)));
    
    for (const originalPost of postsToReplyTo) {
      // Select 1-3 actors to reply
      const replyCount = 1 + Math.floor(Math.random() * 3);
      const replyingActors = shuffleArray(
        allActors.filter(a => a.id !== originalPost.author)
      ).slice(0, replyCount);
      
      for (const actor of replyingActors) {
        // Generate reply content
        const replyContent = await this.generateReplyContent(actor, originalPost);
        
        // Reply timestamp is after original post
        const originalTime = new Date(originalPost.timestamp);
        
        // Validate timestamp
        if (isNaN(originalTime.getTime())) {
          console.warn(`⚠️  Invalid timestamp for post ${originalPost.id}, skipping reply generation`);
          continue;
        }
        
        const replyTime = new Date(originalTime.getTime() + (5 + Math.random() * 55) * 60 * 1000); // 5-60 minutes later
        
        replies.push({
          id: `reply-${originalPost.id}-${actor.id}`,
          day,
          timestamp: replyTime.toISOString(),
          type: 'reply',
          content: replyContent,
          author: actor.id,
          authorName: actor.name,
          replyTo: originalPost.id,
          relatedEvent: originalPost.relatedEvent,
          sentiment: originalPost.sentiment * (Math.random() > 0.5 ? 1 : -1) * (0.5 + Math.random() * 0.5),
          clueStrength: originalPost.clueStrength * 0.5,
          pointsToward: originalPost.pointsToward,
        });
      }
    }
    
    return replies;
  }

  /**
   * Generate reply content for an actor replying to a post
   */
  private async generateReplyContent(actor: Actor, originalPost: FeedPost): Promise<string> {
    if (!this.llm) {
      // Fallback without LLM
      const reactions = ['Interesting take', 'I disagree', 'This is huge', 'Nope', 'Facts', 'Cope', 'Based'];
      return reactions[Math.floor(Math.random() * reactions.length)]!;
    }

    try {
      // Build emotional context
      const emotionalContext = formatActorVoiceContext(actor);

      // Build relationship context if we have the original author's info
      const relationshipContext = '';  // TODO: Add relationship context if available

      const prompt = loadPrompt('feed/reply', {
        actorName: actor.name,
        actorDescription: actor.description || '',
        emotionalContext,
        originalAuthorName: originalPost.authorName,
        originalContent: originalPost.content,
        relationshipContext
      });

      const response = await this.llm.generateJSON<{ post: string; sentiment?: number; clueStrength?: number; pointsToward?: boolean | null }>(
        prompt,
        undefined,
        { temperature: 1.0, maxTokens: 500 }
      );

      return response.post || 'Interesting';
    } catch (error) {
      // Fallback on error
      return 'Interesting take';
    }
  }

  /**
   * BATCHED: Generate ambient posts for multiple actors in ONE call
   * Uses outcome to provide subtle narrative atmosphere for coherence
   */
  private async generateAmbientPostsBatch(
    actors: Actor[],
    day: number,
    outcome: boolean,  // Used to create subtle atmospheric context for narrative coherence
    previousPosts: FeedPost[] = []
  ): Promise<Array<{ post: string; sentiment: number; clueStrength: number; pointsToward: boolean | null }>> {
    if (!this.llm || actors.length === 0) {
      return [];
    }

    // Build context using helper functions
    const phaseContext = buildPhaseContext(day);
    const relationshipContext = buildRelationshipContext(actors, this.relationships);

    const contexts = actors.map(actor => {
      const state = this.actorStates.get(actor.id);
      const emotionalContext = state
        ? generateActorContext(state.mood, state.luck, undefined, this.relationships, actor.id)
        : '';

      return { actor, emotionalContext };
    });

    // Natural progression: early game is setup, mid-game builds tension, late game escalates
    const progressContext = day <= 10
      ? 'Early days - things are just getting started.'
      : day <= 20
        ? 'Mid-way through - developments are unfolding.'
        : 'Late stage - tension is building, things are heating up.';

    // Outcome provides subtle atmospheric context for narrative coherence
    const atmosphereContext = outcome
      ? 'There\'s a sense of forward momentum and positive developments underlying current events.'
      : 'There are underlying tensions and concerns affecting the overall atmosphere.';

    // Build context from previous posts - ambient posts can reference the broader conversation
    const previousPostsContext = previousPosts.length > 0
      ? `\nRecent posts from today:\n${previousPosts.slice(-5).map(p => `- @${p.authorName}: "${p.content}"`).join('\n')}`
      : '';

    const actorsList = contexts.map((ctx, i) =>
      loadPrompt('feed/ambient-instruction', {
        index: (i + 1).toString(),
        actorName: ctx.actor.name,
        actorDescription: ctx.actor.description,
        domain: ctx.actor.domain?.join(', ') || 'general',
        emotionalContext: ctx.emotionalContext,
        voiceContext: formatActorVoiceContext(ctx.actor),
        groupContext: this.actorGroupContexts.get(ctx.actor.id) || ''
      })
    ).join('\n');

    const prompt = loadPrompt('feed/ambient-posts', {
      day,
      progressContext,
      atmosphereContext,
      previousPostsContext,
      actorCount: actors.length,
      actorsList,
      phaseContext,
      relationshipContext
    });

    const maxRetries = 5;
    for (let attempt = 0; attempt < maxRetries; attempt++) {
      const response = await this.llm.generateJSON<{ posts: Array<{ post?: string; tweet?: string; sentiment: number; clueStrength: number; pointsToward: boolean | null }> }>(
        prompt,
        undefined, // Don't validate schema to handle various response formats
        { temperature: 1.1, maxTokens: 5000 }
      );

      const posts = Array.isArray(response.posts) ? response.posts : [];
      const validPosts = posts
        .filter(p => {
          const content = p.post || p.tweet;
          return content && typeof content === 'string' && content.trim().length > 0;
        })
        .map(p => ({
          post: p.post || p.tweet!,
          sentiment: p.sentiment,
          clueStrength: p.clueStrength,
          pointsToward: p.pointsToward,
        }));
      const minRequired = Math.ceil(actors.length * 0.5);
      
      if (validPosts.length >= minRequired) {
        // Limit to requested count to match with actors
        return validPosts.slice(0, actors.length);
      }

      console.warn(`⚠️  Invalid ambient posts batch (attempt ${attempt + 1}/${maxRetries}). Expected ${actors.length}, got ${validPosts.length} valid (need ${minRequired}+)`);
      if (attempt < maxRetries - 1) {
        await new Promise(resolve => setTimeout(resolve, 1000));
      }
    }

    throw new Error(`Failed to generate ambient posts batch after ${maxRetries} attempts`);
  }

  /**
   * Generate thread of replies
   * Actors respond to each other's posts
   * BATCHED: Generates all replies in ONE call
   */
  private async generateThread(day: number, existingPosts: FeedPost[], allActors: Actor[]): Promise<FeedPost[]> {
    const thread: FeedPost[] = [];
    
    if (existingPosts.length === 0) return thread;
    
    // Pick a post to reply to (prefer controversial or from main actors)
    const originalPost = existingPosts[Math.floor(Math.random() * existingPosts.length)];
    if (!originalPost) return thread; // Skip if no post exists

    // 1-3 people reply
    const postingActors = allActors.filter(a =>
      a.id !== originalPost.author
    );
    const repliers = shuffleArray(postingActors).slice(0, 1 + Math.floor(Math.random() * 3));
    
    if (repliers.length === 0) return thread;
    
    // ✅ BATCH: Generate all replies in ONE call
    const replies = await this.generateRepliesBatch(repliers, originalPost);
    
    replies.forEach((reply, i) => {
      const replier = repliers[i];
      if (!replier) return; // Skip if replier doesn't exist

      const baseTime = originalPost.timestamp.substring(0, 11);
      const hour = parseInt(originalPost.timestamp.substring(11, 13));

      thread.push({
        id: `${originalPost.id}-reply-${replier.id}`,
        day,
        timestamp: `${baseTime}${String(hour + i).padStart(2, '0')}:${String(30 + i * 10).padStart(2, '0')}:00Z`,
        type: 'thread',
        content: reply.post,
        author: replier.id,
        authorName: replier.name,
        replyTo: originalPost.id,
        sentiment: reply.sentiment,
        clueStrength: reply.clueStrength,
        pointsToward: reply.pointsToward,
      });
    });

    return thread;
  }

  /**
   * BATCHED: Generate replies for multiple actors in ONE call
   */
  private async generateRepliesBatch(
    actors: Actor[],
    originalPost: FeedPost
  ): Promise<Array<{ post: string; sentiment: number; clueStrength: number; pointsToward: boolean | null }>> {
    if (!this.llm || actors.length === 0) {
      return [];
    }

    // Build context using helper functions
    const relationshipContext = buildRelationshipContext(actors, this.relationships);

    const contexts = actors.map(actor => {
      const state = this.actorStates.get(actor.id);
      const emotionalContext = state
        ? generateActorContext(state.mood, state.luck, originalPost.author, this.relationships, actor.id)
        : '';

      return { actor, emotionalContext };
    });

    const repliersList = contexts.map((ctx, i) => `${i + 1}. ${ctx.actor.name}
   About: ${ctx.actor.description}
   ${ctx.emotionalContext}${formatActorVoiceContext(ctx.actor)}

   Write reply (max 280 chars).
   ${ctx.actor.personality?.includes('contrarian') ? 'Disagree or challenge' : `Consider your relationship and mood when responding`}
   Let emotional state and any relationship with ${originalPost.authorName} influence tone. Match their writing style.
`).join('\n');

    const prompt = loadPrompt('feed/replies', {
      originalAuthorName: originalPost.authorName,
      originalContent: originalPost.content,
      replierCount: actors.length,
      repliersList,
      relationshipContext
    });

    const maxRetries = 5;
    for (let attempt = 0; attempt < maxRetries; attempt++) {
      const response = await this.llm.generateJSON<{ replies: Array<{ post?: string; tweet?: string; sentiment: number; clueStrength: number; pointsToward: boolean | null }> }>(
        prompt,
        undefined, // Don't validate schema to handle various response formats
        { temperature: 1.0, maxTokens: 5000 }
      );

      const replies = Array.isArray(response.replies) ? response.replies : [];
      const validReplies = replies
        .filter(r => {
          const content = r.post || r.tweet;
          return content && typeof content === 'string' && content.trim().length > 0;
        })
        .map(r => ({
          post: r.post || r.tweet!,
          sentiment: r.sentiment,
          clueStrength: r.clueStrength,
          pointsToward: r.pointsToward,
        }));
      const minRequired = Math.ceil(actors.length * 0.5);
      
      if (validReplies.length >= minRequired) {
        // Limit to requested count to match with actors
        return validReplies.slice(0, actors.length);
      }

      console.warn(`⚠️  Invalid replies batch (attempt ${attempt + 1}/${maxRetries}). Expected ${actors.length}, got ${validReplies.length} valid (need ${minRequired}+)`);
      if (attempt < maxRetries - 1) {
        await new Promise(resolve => setTimeout(resolve, 1000));
      }
    }

    throw new Error(`Failed to generate replies batch after ${maxRetries} attempts`);
  }

  /**
   * Generate ambient post (general musing, not tied to events)
   * Public for external use and testing
   */
  public async generateAmbientPost(actor: Actor, day: number, outcome: boolean): Promise<{ post: string; sentiment: number; clueStrength: number; pointsToward: boolean | null }> {
    if (!this.llm) {
      throw new Error('LLM client required for feed generation');
    }

    // Get actor's current emotional state
    const state = this.actorStates.get(actor.id);
    const emotionalContext = state
      ? generateActorContext(state.mood, state.luck, undefined, this.relationships, actor.id)
      : '';

    // Add subtle mood influence based on outcome
    const atmosphereNote = outcome
      ? 'The general atmosphere feels progressive and things are developing.'
      : 'There is subtle tension in the air, things feel uncertain.';

    const progressContext = day < 15 ? 'Be vague or mysterious' : 'Hint at things heating up';
    const outcomeFrame = outcome ? 'Subtle optimism' : 'Subtle skepticism';

    const prompt = loadPrompt('feed/ambient-post', {
      actorName: actor.name,
      actorDescription: actor.description,
      emotionalContext: emotionalContext ? `\n${emotionalContext}\n` : '',
      day,
      progressContext,
      atmosphereNote,
      outcomeFrame
    });

    // Retry until we get non-empty content
    const maxRetries = 5;
    for (let attempt = 0; attempt < maxRetries; attempt++) {
      const response = await this.llm.generateJSON<{ 
        post: string;
        sentiment: number;
        clueStrength: number;
        pointsToward: boolean | null;
      }>(
        prompt,
        { required: ['post', 'sentiment', 'clueStrength', 'pointsToward'] },
        { temperature: 1.1, maxTokens: 5000 }
      );

      // Validate post exists and is not empty
      if (response.post && typeof response.post === 'string' && response.post.trim().length > 0) {
        return response;
      }

      console.error('Invalid response from LLM:', JSON.stringify(response, null, 2));
      console.warn(`⚠️  Invalid post returned (attempt ${attempt + 1}/${maxRetries}). Retrying...`);
      if (attempt < maxRetries - 1) {
        await new Promise(resolve => setTimeout(resolve, 1000));
      }
    }

    // If all retries fail, throw error
    throw new Error(`Failed to generate valid post after ${maxRetries} attempts for ${actor.name}`);
  }

  /**
   * Generate feed posts for stock price movements
   * Creates company announcements, ticker posts, and analyst reactions
   * Public for external use by price engines
   */
  public async generateEconomicFeedPosts(
    priceUpdate: PriceUpdate,
    company: Organization,
    day: number,
    allActors: Actor[]
  ): Promise<FeedPost[]> {
    if (!this.llm) {
      return [];
    }

    const posts: FeedPost[] = [];
    const baseTime = `2025-10-${String(day).padStart(2, '0')}T`;
    const direction = priceUpdate.change > 0 ? 'up' : 'down';
    const phaseContext = buildPhaseContext(day);

    // Only generate posts for significant price movements (>2%)
    if (Math.abs(priceUpdate.changePercent) < 2) {
      return [];
    }

    // 1. Company announcement (for major moves >5%)
    if (Math.abs(priceUpdate.changePercent) >= 5) {
      try {
        const prompt = loadPrompt('game/price-announcement', {
          companyName: company.name,
          priceChange: priceUpdate.change.toFixed(2),
          direction,
          currentPrice: priceUpdate.newPrice.toFixed(2),
          eventDescription: priceUpdate.reason,
          phaseContext
        });

        const response = await this.llm.generateJSON<{
          post: string;
          sentiment: number;
        }>(prompt, undefined, { temperature: 0.8, maxTokens: 500 });

        posts.push({
          id: `${company.id}-price-announcement-${day}`,
          day,
          timestamp: `${baseTime}${String(9 + Math.floor(Math.random() * 2)).padStart(2, '0')}:${String(Math.floor(Math.random() * 60)).padStart(2, '0')}:00Z`,
          type: 'news',
          content: response.post,
          author: company.id,
          authorName: company.name,
          sentiment: response.sentiment,
          clueStrength: 0,
          pointsToward: null,
        });
      } catch (error) {
        console.error('Failed to generate price announcement:', error);
      }
    }

    // 2. Stock ticker style post (always for significant moves)
    try {
      const prompt = loadPrompt('feed/stock-ticker', {
        ticker: company.id.toUpperCase().slice(0, 4),
        companyName: company.name,
        currentPrice: priceUpdate.newPrice.toFixed(2),
        priceChange: priceUpdate.change.toFixed(2),
        direction,
        volume: Math.floor(Math.random() * 1000000 + 500000).toString()
      });

      const response = await this.llm.generateJSON<{
        post: string;
        sentiment: number;
      }>(prompt, undefined, { temperature: 0.7, maxTokens: 300 });

      posts.push({
        id: `${company.id}-ticker-${day}`,
        day,
        timestamp: `${baseTime}${String(9 + Math.floor(Math.random() * 3)).padStart(2, '0')}:${String(Math.floor(Math.random() * 60)).padStart(2, '0')}:00Z`,
        type: 'news',
        content: response.post,
        author: 'market-ticker',
        authorName: 'Market Ticker',
        sentiment: response.sentiment,
        clueStrength: 0,
        pointsToward: null,
      });
    } catch (error) {
      console.error('Failed to generate ticker post:', error);
    }

    // 3. Analyst reactions (1-2 analysts for major moves)
    if (Math.abs(priceUpdate.changePercent) >= 3) {
      const analysts = allActors.filter(a =>
        a.domain?.includes('finance') ||
        a.domain?.includes('business') ||
        a.description?.toLowerCase().includes('analyst')
      ).slice(0, Math.abs(priceUpdate.changePercent) >= 5 ? 2 : 1);

      for (const analyst of analysts) {
        try {
          const state = this.actorStates.get(analyst.id);

          const prompt = loadPrompt('feed/analyst-reaction', {
            analystName: analyst.name,
            analystDescription: analyst.description || '',
            companyName: company.name,
            priceChange: Math.abs(priceUpdate.changePercent).toFixed(1),
            direction,
            eventDescription: priceUpdate.reason,
            mood: state ? (state.mood > 0 ? 'optimistic' : state.mood < 0 ? 'pessimistic' : 'neutral') : 'neutral',
            phaseContext
          });

          const response = await this.llm.generateJSON<{
            post: string;
            sentiment: number;
          }>(prompt, undefined, { temperature: 0.9, maxTokens: 500 });

          posts.push({
            id: `${analyst.id}-analyst-${company.id}-${day}`,
            day,
            timestamp: `${baseTime}${String(10 + Math.floor(Math.random() * 3)).padStart(2, '0')}:${String(Math.floor(Math.random() * 60)).padStart(2, '0')}:00Z`,
            type: 'post',
            content: response.post,
            author: analyst.id,
            authorName: analyst.name,
            sentiment: response.sentiment,
            clueStrength: 0,
            pointsToward: null,
          });
        } catch (error) {
          console.error(`Failed to generate analyst reaction for ${analyst.name}:`, error);
        }
      }
    }

    return posts;
  }

  /**
   * Generate a day transition post marking the start of a new day
   * Creates a narrative summary that acknowledges the previous day and sets tone for today
   * Public for external use by game generators
   */
  public async generateDayTransitionPost(
    day: number,
    previousDayEvents: WorldEvent[],
    questions: Question[],
    allActors: Actor[]
  ): Promise<FeedPost | null> {
    if (!this.llm || day === 1) {
      return null; // No transition post for day 1
    }

    const baseTime = `2025-10-${String(day).padStart(2, '0')}T06:00:00Z`; // Early morning transition
    const phaseContext = buildPhaseContext(day);
    const phaseName = this.getPhaseName(day);

    // Format yesterday's key events
    const eventsContext = previousDayEvents
      .slice(0, 3) // Top 3 events
      .map(e => `- ${e.description}`)
      .join('\n');

    // Format active questions
    const questionsContext = questions
      .filter(q => !q.status || q.status === 'active')
      .slice(0, 3) // Top 3 questions
      .map(q => `- ${q.text}`)
      .join('\n');

    // Format key actors (top tier actors)
    const keyActors = allActors
      .filter(a => a.tier === 'S_TIER' || a.tier === 'A_TIER')
      .slice(0, 5)
      .map(a => a.name)
      .join(', ');

    try {
      const prompt = loadPrompt('game/day-transition', {
        day: day.toString(),
        phaseName,
        phaseContext,
        previousDayEvents: eventsContext || 'None',
        activeQuestions: questionsContext || 'No active questions',
        keyActors: keyActors || 'Various industry figures'
      });

      const response = await this.llm.generateJSON<{
        event: string;
        type: string;
        tone: string;
      }>(prompt, undefined, { temperature: 0.7, maxTokens: 500 });

      return {
        id: `day-transition-${day}`,
        day,
        timestamp: baseTime,
        type: 'news',
        content: response.event,
        author: 'game-narrator',
        authorName: 'Game Narrator',
        sentiment: 0,
        clueStrength: 0,
        pointsToward: null,
      };
    } catch (error) {
      console.error(`Failed to generate day transition post for day ${day}:`, error);
      return null;
    }
  }

  /**
   * Generate a feed post announcing a question resolution
   * Creates a public announcement when a prediction market question resolves
   * Public for external use by game generators
   */
  public async generateQuestionResolutionPost(
    question: Question,
    resolutionEventDescription: string,
    day: number,
    winningPercentage: number = 50
  ): Promise<FeedPost | null> {
    if (!this.llm) {
      return null;
    }

    const baseTime = `2025-10-${String(day).padStart(2, '0')}T20:00:00Z`; // Evening announcement
    const outcomeText = question.resolvedOutcome ? 'YES' : 'NO';

    try {
      const prompt = loadPrompt('game/question-resolved-feed', {
        questionText: question.text,
        outcome: outcomeText,
        resolutionEvent: resolutionEventDescription,
        winningPercentage: winningPercentage.toFixed(0)
      });

      const response = await this.llm.generateJSON<{
        post: string;
        sentiment: number;
      }>(prompt, undefined, { temperature: 0.7, maxTokens: 400 });

      return {
        id: `question-resolved-${question.id}-${day}`,
        day,
        timestamp: baseTime,
        type: 'news',
        content: response.post,
        author: 'market-oracle',
        authorName: 'Market Oracle',
        sentiment: response.sentiment,
        clueStrength: 0,
        pointsToward: null,
      };
    } catch (error) {
      console.error(`Failed to generate question resolution post for question ${question.id}:`, error);
      return null;
    }
  }

  /**
   * Generate minute-level ambient post for continuous mode
   * Uses actor personality and current context for realistic posts
   */
  public async generateMinuteAmbientPost(
    actor: { id: string; name: string; description?: string; role?: string; mood?: number },
    timestamp: Date
  ): Promise<{ content: string; sentiment: number; energy: number } | null> {
    if (!this.llm) {
      return null;
    }

    try {
      // Build context for the post
      const currentTime = timestamp.toLocaleString('en-US', {
        weekday: 'long',
        month: 'long',
        day: 'numeric',
        hour: 'numeric',
        minute: '2-digit',
      });

      const emotionalContext = actor.mood
        ? `Current mood: ${actor.mood > 0 ? 'positive' : actor.mood < 0 ? 'negative' : 'neutral'}`
        : '';

      const atmosphereContext = ''; // Can be enhanced with recent events context

      const prompt = loadPrompt('feed/minute-ambient', {
        actorName: actor.name,
        actorDescription: actor.description || actor.role || 'industry professional',
        emotionalContext,
        currentTime,
        atmosphereContext,
      });

      const response = await this.llm.generateJSON<{
        post: string;
        sentiment: number;
        energy: number;
      }>(prompt, undefined, { temperature: 1.0, maxTokens: 300 });

      return {
        content: response.post,
        sentiment: response.sentiment,
        energy: response.energy,
      };
    } catch (error) {
      console.error(`Failed to generate ambient post for actor ${actor.name}:`, error);
      return null;
    }
  }

  /**
   * Get phase name for a given day
   */
  private getPhaseName(day: number): string {
    if (day <= 10) return 'WILD';
    if (day <= 20) return 'CONNECTION';
    if (day <= 25) return 'CONVERGENCE';
    if (day <= 29) return 'CLIMAX';
    return 'RESOLUTION';
  }

  /**
   * Generate reply to another post
   * React based on personality, mood, and relationship
   * Public for external use and testing
   */
  public async generateReply(actor: Actor, originalPost: FeedPost): Promise<{ post: string; sentiment: number; clueStrength: number; pointsToward: boolean | null }> {
    if (!this.llm) {
      throw new Error('LLM client required for feed generation');
    }

    // Get actor's current emotional state and relationship with the original poster
    const state = this.actorStates.get(actor.id);
    const emotionalContext = state
      ? generateActorContext(state.mood, state.luck, originalPost.author, this.relationships, actor.id)
      : '';

    const relationshipContext = actor.personality?.includes('contrarian')
      ? 'Disagree or challenge'
      : 'Consider your relationship and mood when responding';

    const prompt = loadPrompt('feed/reply', {
      actorName: actor.name,
      actorDescription: actor.description,
      emotionalContext: emotionalContext ? `\n${emotionalContext}\n` : '',
      originalAuthorName: originalPost.authorName,
      originalContent: originalPost.content,
      relationshipContext
    });

    // Retry until we get non-empty content
    const maxRetries = 5;
    for (let attempt = 0; attempt < maxRetries; attempt++) {
      const response = await this.llm.generateJSON<{ 
        post: string;
        sentiment: number;
        clueStrength: number;
        pointsToward: boolean | null;
      }>(
        prompt,
        { required: ['post', 'sentiment', 'clueStrength', 'pointsToward'] },
        { temperature: 1.0, maxTokens: 5000 }
      );

      // Validate post exists and is not empty
      if (response.post && typeof response.post === 'string' && response.post.trim().length > 0) {
        return response;
      }

      console.error('Invalid response from LLM:', JSON.stringify(response, null, 2));
      console.warn(`⚠️  Invalid reply returned (attempt ${attempt + 1}/${maxRetries}). Retrying...`);
      if (attempt < maxRetries - 1) {
        await new Promise(resolve => setTimeout(resolve, 1000));
      }
    }

    // If all retries fail, throw error
    throw new Error(`Failed to generate valid reply after ${maxRetries} attempts for ${actor.name}`);
  }

}

